---
title: CSAPP-Ch02_Bits & Bytes & Integer & Floating Point
categories: [csapp]
tags: [csapp]
---

3种重要的数字表示：

- unsigned
- two's complement
- floating point

阅读技巧：首先给出以数学形式表示的属性，作为原理。然后，用例子和非形式化的讨论来解释这个原理。我们建议你反复阅读原理描述和它的示例与讨论，直到你对该属性的说明内容及其重要性有了牢固的直觉。对于更加复杂的属性，还会提供推导，其结构看上去将会像一个数学证明。虽然最终你应该尝试理解这些推导，但在第一次阅读时你可以跳过它们。

## 1 信息存储

大多数计算机使用 8 位的块，或者字节（byte），作为最小的可寻址的内存单位，而不是访问内存中单独的位。

### 虚拟内存

- 机器级程序将内存视为一个非常大的字节数组，称为**虚拟内存（virtual memory）**。
- 内存的每个字节都由一个唯一的数字来标识，称为它的**地址（address）**
- 所有可能地址的集合就称为**虚拟地址空间（virtual address space）**。顾名思义，这个虚拟地址空间只是一个展现给机器级程序的概念性映像。
- 实际的实现（见第 9 章）是将动态随机访问存储器（DRAM）、闪存、磁盘存储器、特殊硬件和操作系统软件结合起来，为程序提供一个看上去统一的字节数组。
- 本章重点是编译器和运行时系统是如何将存储器空间划分为更可管理的单元，来存放不同的程序对象（program object），即程序数据、指令和控制信息。

可以用各种机制来分配和管理程序不同部分的存储。这种管理完全是在虚拟地址空间里完成的。

- 例如，C 语言中一个指针的值（无论它指向一个整数、一个结构或是某个其他程序对象）都是某个存储块的第一个字节的虚拟地址。
- C 编译器还把每个指针和类型信息联系起来，这样就可以根据指针值的类型，生成不同的机器级代码来访问存储在指针所指向位置处的值。
- 尽管 C 编译器维护着这个类型信息，但是它生成的实际机器级程序并不包含关于数据类型的信息。

每个程序对象可以简单地视为一个字节块，而程序本身就是一个字节序列。

### 十六进制表示法

### 字数据大小

![2-3](2-3.png)

每台计算机都有一个字长（word size），指明指针数据的标称大小（nominal size）。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。也就是说，对于一个字长为 w 位的机器而言，虚拟地址的范围为 $0-2^w-1$，程序最多访问 $2^w$个字节。

```sh
linux> gcc -m32 prog.c
```

#### C 语言数据类型分配字节数（C标准保证的字节数和典型的字节数之间的关系）

为了避免由于依赖“典型”大小和不同编译器设置带来的奇怪行为，`ISO C99` 引人了一类数据类型，其数据大小是固定的，不随编译器和机器设置而变化。其中就有数据类型 `int32_t` ,`int64_t`, 分别为 4 和 8 个字节

大部分数据类型都编码为有符号数值，除非有前缀关键字 `unsigned` 或对确定大小的数据类型使用了特定的无符号声明。

> 数据类型 char 是一个例外。尽管大多数编译器和机器将它们视为有符号数，但 C 标准不保证这一点。
>
> 相反，正如方括号指示的那样，程序员应该用有符号字符的声明来保证其为一个字节的有符号数值。
>
> 不过，在很多情况下，程序行为对数据类型 char 是有符号的还是无符号的并不敏感。

大多数机器支持两种不同的浮点数格式：单精度 float & 双精度 double

以下声明都一样

```c
unsigned long
unsigned long int
long unsigned
long unsigned int
```

#### 声明指针

```c
T *p;		// 对于任何数据类型 T，p 是一个指针变量，指向一个类型为 T 的对象
char *p	// 将一个指针声明为指向一个 char 类型的对象
```

可移植性的一个方面就是使程序对不同数据类型的确切大小不敏感。**C 语言标准对不同数据类型的数字范围设置了下界（这点在后面还将讲到），但是却没有上界。**

> 因为从 1980 年左右到 2010 年左右，32 位机器和 32 位程序是主流的组合，许多程序的编写都假设为图 2-3 中 32 位程序的字节分配。随着 64 位机器的日益普及，在将这些程序移植到新机器上时，许多隐藏的对字长的依赖性就会显现出来，成为错误。
>
> 比如，许多程序员假设一个声明为 int 类型的程序对象能被用来存储一个指针。这在大多数 32 位的机器上能正常工作，但是在一台 64 位的机器上却会导致问题。

### 寻址和字节顺序

对于跨越多字节的程序对象，我们必须建立两个规则：

- 这个对象的地址是什么
- 在内存中如何排列这些字节

在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。

> 例如，假设一个类型为 int 的变量×的地址为 0x100, 也就是说，地址表达式&×的值为 0x100。
>
> 那么，（假设数据类型 int 为 32 位表示）x 的 4 个字节将被存储在内存的 0x100、0x101、0x102 和 0x103 位置。

**排列表示一个对象的字节有两个通用的规则** ：考虑一个 w 位的整数，位表示为 $[x_{w-1},x_{w-2},x_{w-3},...x_{1},x_{0}]$

- 其中 x<sub>w-1</sub> 是最高有效位，x<sub>0</sub> 是最低有效位
- 假设 w 是 8 的倍数，这些位就能被分组为字节，其中最高有效字节包含位 $[x^{w-1},x^{w-2},x^{w-3} x^{w-4},x^{w-5},x^{w-6},x^{w-7}]$，最低有效字节位包含 $[x^{7},x^{6},x^{5},x^{4},x^{3},x^{2},x^{1},x^{0}],$ 其他字节包含中间的位。

#### 字节顺序

- 某些机器选择在内存中按照从最低有效字节到最高有效字节的顺序存储对象，而另一些机器则按照从最高有效字节到最低有效字节的顺序存储。

- 前一种规则一最低有效字节在最前面的方式，称为**小端法（little endian）**。后一种规则一最高有效字节在最前面的方式，称为**大端法（big endian)**

- 双端法

- 对于大多数应用程序员来说，其机器所使用的字节顺序是完全不可见的。无论为哪种类型的机器所编译的程序都会得到同样的结果。

- 不过有时候，字节顺序会成为问题。

  - 首先是在不同类型的机器之间通过网络传送二进制数据时，一个常见的问题是当小端法机器产生的数据被发送到大端法机器或者反过来时，接收程序会发现，字里的字节成了反序的。为了避免这类问题，网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则，以确保发送方机器将它的内部表示转换成网络标准，而接收方机器则将网络标准转换为它的内部表示。

    我们将在第 11 章中看到这种转换的例子。

  - 第二种情况是，当阅读表示整数数据的字节序列时，字节顺序也很重要。这通常发生在检查机器级程序时。

  - 第三种情况是当编写规避正常的类型系统的程序时。C语言可以通过使用强制类型转换（cast） 或联合（union）来允许以一种数据类型引用一个对象，而这种数据类型与创建这个对象时定义的数据类型不同。大多数应用编程都强烈不推荐这种编码技巧，但是它们对系统级编程来说是非常有用，甚至是必需的。

    ```c
    /* 
    打印程序对象的字节表示。这段代码使用强制类型转换来规避类型系统。
    很容易定义针对其他数据类型的类似函数.
    分别输出类型为 int、f1oat 和 void*的 C 程序对象的字节表示。
    * 可以观察到它们仅仅传递给 show bytes 一个指向它们参数 x 的指针&x，且这个指针被强制类型转换为“unsigned char*”。
    * 这种强制类型转换告诉编译器，程序应该把这个指针看成指向一个字节序列，而不是指向一个原始数据类型的对象。
    * 然后，这个指针会被看成是对象使用的最低字节地址。
    */ 
    #include <stdio.h>
    
    typedef unsigned char *byte_pointer;
    
    void show_bytes(byte_pointer start, size_t len) {
    	size_t i;
    	for (i = 0; i < len; i++) {
    		printf("%.2x\n", start[i]);
    	}
    }
    
    void show_int(int x) {
    	show_bytes((byte_pointer) &x, sizeof(int));
    }
    
    void show_float(int x) {
    	show_bytes((byte_pointer) &x, sizeof(float));
    }
    
    void show_pointer(void *x) {
    	show_bytes((byte_pointer) &x, sizeof(void *));
    }
    ```
  
    参数 12345 的十六进制表示为 0x00003039。对于 int 类型的数据，除了字节顺序以外，我们在所有机器上都得到相同的结果。特别地，我们可以看到在 Linux32、Windows 和 Linux64 上，最低有效字节值 0x39 最先输出，这说明它们是小端法机器；而在 Sun 上最后输出，这说明 Sun 是大端法机器。同样地，float 数据的字节，除了字节顺序以外， 也都是相同的。另一方面，**指针值却是完全不同的**。不同的机器/操作系统配置使用不同的存储分配规则。一个值得注意的特性是 Linux32、Windows 和 Sun 的机器使用 4 字节地址，而 Linux64 使用 8 字节地址。

    ![2-6](2-6.png)
    
    可以观察到，尽管浮点型和整型数据都是对数值 12345 编码，但是它们有截然不同的字节模式：整型为 0x00003039, 而浮点数为 0x4640E400。一般而言，这两种格式使用不同的编码方法。如果我们将这些十六进制模式扩展为二进制形式，并且适当地将它们移位，就会发现一个有 13 个相匹配的位的序列，用一串星号标识出来：![float](float.png)

#### C 语言技巧

##### 使用 typedef 命名数据类型

```c
typedef int *int_pointer; // 将类型 int_pointer 定义为一个指向 int 的指针，并且声明了一个这种类型的变量 ip
int_pointer ip;

int *ip
```

##### 使用 printf 格式化输出：对格式化细节的控制能力

> 指定确定大小数据类型的格式，如 it32t，要更复杂一些，相关内容参见 2.2.3 节的旁注。

##### 指针和数组

> 在 C 语言中，我们能够用数组表示法来引用指针，同时我们也能用指针表示法来引用数组元素。在这个例子中，引用 start [i】表示我们想要读取以 start 指向的位置为起始的第 i 个位置处的字节。



##### 指针的创建和间接引用

> C 的“取地址”运算符 & 创建一个指针。在这三行中，表达式 &x 创建了一个指向保存变量 x 的位置的指针。这个指针的类型取决于 x 的类型，因此这三个指针的类型分别为 int*、f1oat*和 void。（数据类型 void 是一种特殊类型的指针，没有相关联的类型信息。）
>
> 强制类型转换运算符可以将一种数据类型转换为另一种。因此，强制类型转换 (byte pointer)&x 表明无论指针&x 以前是什么类型，它现在就是一个指向数据类型为 unsigned char 的指针。这里给出的这些强制类型转换不会改变真实的指针，它们只是告诉编译器以新的数据类型来看待被指向的数据。
>

##### 生成一张 ASCII 表

```shell
man ascii
```



### 表示字符串

C 语言中字符串被编码为一个以 nuIl（其值为 0) 字符结尾的字符数组。每个字符都由某个标准编码来表示，最常见的是 ASCII 字符码。

因此，如果我们以参数“12345”和 6（包括终止符）来运行例程 show bytes，我们得到结果 31 32 33 34 35 00。

请注意，十进制数字 x 的 ASCII 码正好是 0x3x，而终止字节的十六进制表示为 0x00。在使用 ASCII 码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关。因而，文本数据比二进制数据具有更强的平台独立性。



### 表示代码

计算机系统的一个基本概念：从机器的角度来看，程序仅仅只是字节序列。



### 布尔代数 & 位向量

#### 位向量的运算

- 位向量就是固定长度为 w、由 0 和 1 组成的串。
- 位向量的运算可以定义成参数的每个对应元素之间的运算。
- 假设 α 和 b 别表示位向量$[a_{w-1}, a_{w-2}, …, a_{0}] $和$[b_{w-1}, b_{w-2}, …, b_{0}]$。我们将 a&b 也定义为一个长度为 w 的位向量，其中第 i 个元素等于 a<sub>i</sub> & b<sub>i</sub>:,0≤i<w。
- 可以用类似的方式将运算 |, ^, 和 ~ 扩展到位向量上。

#### 位向量-表示有限集合

- 我们可以用位向量 $[a_{w-1}, a_{w-2}, …, a_{0}] $ 编码任何子集 $A⊆\lbrace{0,1,…,w-1}\rbrace$，其中 a<sub>i</sub>=1 当且仅当 i∈A。

  > 例如（记住我们是把 $a_{w-1}$ 写在左边，而将 $a_0$ 写在右边），位向量 $a ≐ [01101001]$ 表示集合 $A=\lbrace{0,3,5,6}\rbrace$，而 $b≐[01010101]$ 表示集合 $B=\lbrace0,2,4,6\rbrace$。

- 使用这种编码集合的方法，布尔运算 | 和 & 分别对应于集合的并和交，而 ~ 对应于于集合的补。还是用前面那个例子，运算 $α\&b$ 得到位向量 $[01000001]$，而 $A∩B=\lbrace0,6\rbrace$。

- 在大量实际应用中，我们都能看到用位向量来对集合编码。

  > 例如，在第 8 章，我们会看到有很多不同的信号会中断程序执行。我们能够通过指定一个位向量掩码，有选择地使能或是屏蔽一些信号，其中某一位位置上为 1 时，表明信号 i 是有效的（使能），而 0 表明该信号是被屏蔽的。因而，这个掩码表示的就是设置为有效信号的集合。

#### 关于布尔代数和布尔环的更多内容

![bool](bool.png)

#### 练习题

![boolExe](boolExe.png)

### C 语言中的位级运算

#### C 语言支持按位布尔运算

这些运算能运用到任何 “整型” 数据类型上

正如示例说明的那样，确定一个位级表达式的结果最好的方法，就是将十六进制的参数扩展成二进制表示并执行二进制运算，然后再转换回十六进制。![xor](xor.png)

#### 位级运算的一个常见用法就是实现掩码运算

这里掩码是一个位模式，表示从一个字中选出的位的集合。

> 例子：掩码 0xFF（最低的 8 位为 1) 表示一个字的低位字节。位级运算 x&0xFF 生成一个由 x。的最低有效字节组成的值，而其他的字节就被置为 0。
>
> 比如，对于 x=0x89ABCDEF，其表达式将得到 0x000000EF。表达式 ~0 将生成一个全1的掩码，不管机器的字大小是多少。
>
> 尽管对于一个 32 位机器来说，同样的掩码可以写成 0xFFFFFFFF，但是这样的代码不是可移植的。

### C 语言中的逻辑运算

C 语言还提供了一组逻辑运算符 ‖、&&和 !，分别对应于命题逻辑中的 OR、AND 和 OT 运算。

逻辑运算很容易和位级运算相混淆，但是它们的功能是完全不同的。

逻辑运算认为所有非零的参数都表示 TRUE，而参数 0 表示 FALSE。它们返回 1 或者 0，分别表示结果为 TRUE 或者为 FALSE。以下是一些表达式求值的示例。

逻辑运算符&&和‖与它们对应的位级运算&和|之间第二个重要的区别是，如果对第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。因此，例如，表达式a&&5/a将不会造成被零除，而表达式p&&*p++也不会导致间接引用空指针。

### C 语言中的移位运算

对于一个位表示为 $[x_{w-1}, x_{w-2}, …, x_{0}] $ 的操作数 x, C 表达式 $x\ll k$ 会生成一个值，其位表示为 $[x^{w-k-1},x^{w-k-2},...,x^{0},0,...,0]$。也就是说，x 向左移动 k 位，丢弃最高的 k 位，并在右端补 k 个 0。移位量应该是一个 $0\sim(w-1)$ 之间的值。移位运算是从左至右可结合的，所以 $x\ll j\ll k$  等价于$(x\ll j)\ll k$

有一个相应的右移运算 x>>k，但是它的行为有点微妙。一般而言，机器支持两种形式的右移：

- 逻辑右移算术右移逻辑右移在左端补 k 个 0，得到的结果是 
  $$
  [0,...,0,x^{w-1},x^{w-2},...,x^{k}]
  $$

- 算术右移是在左端补及个最高有效位的值，得到的结果是 $[x_{w-1},...,x_{w-1},x_{w-1},x_{w-2},...,x_{k}]$。这种做法看上去可能有点奇特，但是我们会发现它对有符号整数数据的运算非常有用。

让我们来看一个例子，下面的表给出了对一个 8 位参数×的两个不同的值做不同的移位操作得到的结果：

| Operation                | Value                     |
| ------------------------ | ------------------------- |
| Parameter x              | [01100011] [10010101]     |
| x << 4                   | [0011*0000*] [0101*0000*] |
| x >> 4(Logical shift)    | [*0000*0110] [*0000*1001] |
| x >> 4(arithmetic shift) | [*0000*0110] [*1111*1001] |

斜体的数字表示的是最右端（左移）或最左端（右移）填充的值。可以看到除了一个条目之外，其他的都包含填充 0。唯一的例外是算术右移 $[10010101]$ 的情况。因为操作数的最高位是 1，填充的值就是 1。

C 语言标准并没有明确定义对于有符号数应该使用哪种类型的右移一算术右移或者逻辑右移都可以。不幸地，这就意味着任何假设一种或者另一种右移形式的代码都可能会遇到可移 植性问题。然而，实际上，几乎所有的编译器/机器组合都对有符号数使用算术右移，且许多程序员也都假设机器会使用这种右移。另一方面，对于无符号数，右移必须是逻辑的。

与 C 相比，Jva 对于如何进行右移有明确的定义。表达是 $x\gg k$ 会将 x 算术右移 k 个位置，而 $x\gg k$ 会对 x 做逻辑右移。

#### 旁注移动 K 位，这里 k 很大

对于一个由位组成的数据类型，如果要移动 $k≥w$ 位会得到什么结果呢？例如，计算下面的表达式会得到什么结果，假设数据类型 int 为 w=32：

```c
int 	 lval = 0xFEDCBA98  	<<32;
int 	 aval = 0xFEDCBA98  	>>36;
unsigned uval = OxFEDCBA98u >>40;
```

C 语言标准很小心地规避了说明在这种情况下该如何做。在许多机器上，当移动一个w位的值时，移位指令只考虑位移量的低 $log_2w$ 位，因此实际上位移量就是通过计算 $k\mod w$ 得到的。例如，当 $ω=32$ 时，上面三个移位运算分别是移动 0、4 和 8 位，得到结果：

```c
lval 0xFEDCBA98
aval OxFFEDCBA9
uval OxOOFEDCBA
```

不过这种行为对于 C 程序来说是没有保证的，所以应该保持位移量小于待移位值的位数

另一方面，Java 特别要求位移数量应该按照我们前面所讲的求模的方法来计算。

## 2 整数表示

![2-8](2-8.png)

### 整型数据类型

C 语言支持多种整型数据类型——表示有限范围的整数。![2-9](2-9.png)![2-10](/Users/mac/github/zennlyu.github.io/hexo/source/statics/csapp/2-10.png)

每种类型都能用关键字来指定大小，这些关键字包括 char、short、long，同时还可以指示被表示的数字是非负数（声明为 unsigned），或者可能是负数（默认）。

如图 2-3 所示，为这些不同的大小分配的字节数根据程序编译为 32 位还是 64 位而有所不同。根据字节分配，不同的大小所能表示的值的范围是不同的。这里给出来的唯一一个与机器相关的取值范围是大小指示符 log 的。大多数 64 位机器使用 8 个字节的表示，比 32 位机器上使用的 4 个字节的表示的取值范围大很多。

图 2-9 和图 2-10 中一个很值得注意的特点是取值范围不是对称的一负数的范围比整数的范围大 1。当我们考虑如何表示负数的时候，会看到为什么会这样。![2-11](2-11.png)

C 语言标准定义了每种数据类型必须能够表示的最小的取值范围。特别地，除了固定大小的数据类型是例外，我们看到它们只要求正数和负数的取值范围是对称的。

此外，数据类型 int 可以用 2 个字节的数字来实现，而这几乎回退到了 16 位机器的时代。

还可以看到，log 的大小可以用 4 个字节的数字来实现，对 32 位程序来说这是很典型的。固定大小的数据类型保证数值的范围与图 2-9 给出的典型数值一致，包括负数与正数的不对称性。

### 无符号数的编码

#### 无符号编码的定义

假设有一个整数数据类型有 $w$ 位。我们可以将位向量写成 $\vec{x}$，表示整个向量，或者写成 $[x_{w-1}, x_{w-2}, …, x_{0}]$: ，表示向量中的每一位。把 $\vec{x}$ 看做一个二进制表示的数，就获得了 $\vec{x}$  的无符号表示。在这个编码中，每个位 $x_i$ 都取值为 0 或 1，后一种取值意味着数值 $2^i$ 应为数字值的一部分。我们用一个函数 $B2U$ (Binary to Unsigned 的缩写，长度为 $w$）来表示：

对于向量 $\vec{x}=[x_{w-1}, x_{w-2}, …, x_{0}]$: 

$$
\begin{align} B2U_w(\vec{x})≐\sum\limits_{i=0}^{w-1}x_i2^i \end{align}
$$


在这个等式中，符号“≐”表示左边被定义为等于右边。

函数 B2Uw 将一个长度为的 0、1 串映射到非负整数。

> 举一个示例，图 2-11 展示的是下面几种情况下 B2U 给出的从位向量到整数的映射：

让我们来考虑一下位所能表示的值的范围。

- 最小值是用位向量 [00… 0] 表示，也就是整数值 0，而最大值是用位向量 [11…1] 表示，也就是整数值。

   $$
   \begin{align} UMax_w≐\sum\limits_{i=0}^{w-1}2^i=2^w-1\end{align}
   $$

- 以4位情况为例，$UMax_4=B2U_4([1111]) =2^4-1=15$

- 因此，函数 B2U 能够被定义为一个映射 

  $$\begin{align} B2U_w:\lbrace0,1\rbrace^w→\lbrace0，… ,2^w-1\rbrace \end{align}$$.

无符号数的二进制表示有一个很重要的属性，也就是每个介于 $0\sim2^w-1$ 之间的数都有唯一一个位的值编码。例如，十进制值 11 作为无符号数，只有一个 4 位的表示，即 $[1011]$。我们用数学原理来重点讲述它，先表述原理再解释。 

#### 原理：无符号数编码的难一性：函数 $B2U_w$ 是一个双射

数学术语双射是指一个函数 $f$ 有两面：它将数值 $x$ 映射为数值 $y$，即 $y=f(x)$

但它也可以反向操作，因为对每一个 $y$ 而言，都有唯一一个数值 $x$ 使得 $f(x)=y$。这可以用反函数 $f^{-1}$ 来表示，在本例中，即 $x=f^{-1}(y)$。函数 $B2U$ 将每一个长度为的位向量都映射为 $0\sim 2^w-1$ 之间的一个唯一值；反过来，我们称其为 $U2B_w$（即“无符号数到二进制”），在 $0\sim 2^w-1$ 之间的每一个整数都可以映射为一个唯一的长度为 $w$ 的位模式。



### 补码编码

#### 补码编码的定义

对于向量 $\vec{x}=[x_{w-1}, x_{w-2}, …, x_{0}]$： 

$$
\begin{align}B2T_w(\vec{x})≐-x_{w-1}2^{w-1}+\sum\limits_{i=0}^{w-2}x_i2^i\end{align}
$$

> 最高有效位 $x_{w-1}$也称为符号位，它的“权重”为 $-2^{w-1}$，是无符号表示中权重的负数。
>
> 符号位被设置为 1 时，表示值为负，而当设置为 0 时，值为非负。
>
> 这里来看一个示例，图 2-13 展示的是下面几种情况下 $B2T$ 给出的从位向量到整数的映射。
>
> ![2.4](2.4.png)

![2-13](2-13.png)

在这个图中，我们用向左指的条表示符号位具有负权重。于是，与一个位向量相关联的数值是由可能的向左指的条和向右指的条加起来决定的。

我们可以看到，图 2-12 和图 2-13 中的位模式都是一样的，对等式（2.2) 和等式（2.4) 来说也是一样，但是当最高有效位是 1 时，数值是不同的，这是因为在一种情况中，最高有效位的权重是+8，而在另一种情况中，它的权重是 -8。

让我们来考虑一下 w 位补码所能表示的值的范围。它能表示的最小值是位向量 [10…0] (也就是设置这个位为负权，但是清除其他所有的位），其整数值为 $TMin_w≐-2^{w-1}$, 而最大值是位向量 $[01...1]$，（清除具有负权的位，而设置其他所有的位），其整数值为
$$
TMax_w≐\sum\limits_{i=0}^{w-2}2^i=2^{w-1}-1
$$


以长度 4 为例，我们有

- $TMin_4=B2T_4([1000])=-2^3=-8$，而

- $TMax_4=B2T_4([0111])=2^2+2^1+2^0=4+2+1=7$

我们可以看出 $B2T_w$ 是一个从长度为 $w$ 的位模式到 $TMin_w$ 和 $TMax_w$ 之间数字的映射，写作$B2T_w:\left(0,1\right)^w\rightarrow\left(TMin_w, ..., Tmax_w\right)$ 。同无符号表示一样，在可表示的取值范围内的每个数字都有一个唯一的位的补码编码。这就导出了与无符号数相似的补码数原理：

#### 补码编码的唯一性

函数 B2T 是一个双射。

我们定义函数 $T2B$（即“补码到二进制”）作为 $B2T$ 的反函数。也就是说，对于每个数 x，满足 $TMin_w≤x≤ TMax_w$，则 $T2B(x)$是 x 的（唯一的）w 位模式。

图 2-14 展示了针对不同字长，几个重要数字的位模式和数值。前三个给出的是可表示的整数的范围，用 $UMax_w、TMin_w$ 和 $TMax_w$ 来表示。在后面的讨论中，我们还会经常引用到这三个特殊的值。如果可以从上下文中推断出 w，或者不是讨论的主要内容时，我们会省略下标 w，直接引用 $UMax、TMin$ 和 $TMax$。



#### 补码运算的特殊性

1. $|TMin|=|TMax|+1$, TMin 没有对应的正数
2. 最大的无符号数值刚好比补码的最大值的两倍大一点：$UMax_w=2TMax_w+1$。补码表示中所有表示负数的位模式在无符号表示中都变成了正数。图 2-14 也给出了常数 -1 和 0 的表示。注意 -1 和 $UMax$ 有同样的位表示 —— 一个全 1 的串。数值 0 在两种表示方式中都是全 0 的串。

语言标准并没有要求要用补码形式来表示有符号整数，但是几乎所有的机器都是这么做的。程序员如果希望代码具有最大可移植性，能够在所有可能的机器上运行，那么除了图 2-11 所示的那些范围之外，我们**不应该假设任何可表示的数值范围**，**也不应该假设有符号数会使用何种特殊的表示方式**。

**另一方面，许多程序的书写都假设用补码来表示有符号数**，并且具有图 2-9 和图 2-10 所示的“典型的”取值范围，这些程序也能够在大量的机器和编译器上移植。C 库中的文件 `limits.h` 定义了一组常量，来限定编译器运行的这台机器的不同整型数据类型的取值范围。

> 比如，它定义了常量 `INT_MAX、INT_MIN` 和 `UINT_MAX`，它们描述了有符号和无符号整数的范围。

对于一个补码的机器，数据类型 int 有 w 位，这些常量就对应于 $TMax_w、TMin_w$ 和 $UMax_w$ 的值。

关于**整数数据类型的取值范围和表示，Java 标准是非常明确的**。它要求采用补码表示，取值范围与图 2-10 中 64 位的情况一样。在 Java 中，单字节数据类型称为 byte，而不是 char。这些非常具体的要求都是为了保证无论在什么机器上运行，Java 程序都能表现地完全一样。

为了更好地理解补码表示，考虑下面的代码：

```c
short x = 12345;
short mx = -x;

show_bytes((byte_pointer) &x,  sizeof(short));
show_bytes((byte_pointer) &mx, sizeof(short));
```

当在大端法机器上运行时，这段代码的输出为 `30 39` 和 `cf c7`, 指明 x 的十六进制表示为 `0x3039`, 而 `mx` 的十六进制表示为 `0xCFC7`。将它们展开为二进制，我们得到 x 的位模式为 [0011000000111001]，而 mx 的位模式为[1100111111000111]。如图 2-15 所示，等式(2.3)对这两个位模式生成的值为 12 345 和 -12 345。

![2-15](2-15.png)





#### 关于确定大小的整数类型的更多内容

#### 有符号数的其他表示方法

1. ##### 反码（Ones’ Complement）

   除了最高有效位的权是 $-(2^{w-1}一1)$ 而不是 $-2^{w-1}$, 它和补码是一样的：
   $$
   B2O_w(\vec x)≐-x_{w-1}(2^{w-1}-1)+\sum\limits_{i=0}^{w-2}x_i2^i
   $$

2. ##### 原码（Sign-Magnitude）

   最高有效位是符号位，用来确定剩下的位应该取负权还是正权：
   $$
   B2S_w(\vec x)≐(-1)^{x_{w-1}}·(\sum\limits_{i=0}^{w-2}x_i2^i)​
   $$

这两种表示方法都有一个奇怪的属性，那就是**对于数字有两种不同的编码方式。**

这两种表示方法，把 [00…0] 都解释为 +0。而值 -0 在原码中表示为 [10…0]，在反码中表示为 [11…1]。虽然过去生产过基于反码表示的机器，但是几乎所有的现代机器都使用补码。我们将看到在浮点数中有使用原码编码。

请注意补码（Two’ s complement）和反码（Ones’ complement）中撇号的位置是不同的。术语补码来源于这样一个情况，对于非负数 x，我们用 $2^w- x$（这里只有一个 2) 来计算 -x 的 w 位表示。术语反码来源于这样一个属性，我们用 $[111…1]-x$（这里有很多个 1) 来计算 -x 的反码表示。





### 有符号数和无符号数的转换

C 语言允许在各种不同的数字数据类型之间做强制类型转换。例如，假设变量声明为 int, u 声明为 unsigned。表达式 `(unsigned)x` 会将 x 的值转换成一个无符号数值，而 `(int) u` 将 u 的值转换成一个有符号整数。将有符号数强制类型转换成无符号数，或者反过来，会得到什么结果呢？从数学的角度来说，可以想象到几种不同的规则。

很明显，对于在两种形式中都能表示的值，我们是想要保持不变的。另一方面，将负数转换成无符号数可能会得到。如果转换的无符号数太大以至于超出了补码能够表示的范围，可能会得到 $TMax$。不过，对于大多数 C 语言的实现来说，对这个问题的回答都是从位级角度来看的，而不是数的角度。

比如说，考虑下面的代码：

```c
short int v = -12345;
unsigned short uv = (unsigned short) v;
printf("v=%d, uv=%u", v, uv);
```

在一台采用补码的机器上，上述代码会产生如下输出：

```c
v = -12345, uv = 53191
```

我们看到，强制类型转换的结果保持位值不变，只是改变了解释这些位的方式。在图 2-15 中我们看到过，一 12345 的 16 位补码表示与 53191 的 16 位无符号表示是完全一样的。将 short 强制类型转换为 unsigned short 改变数值，但是不改变位表示。

类似地，考虑下面的代码：

```c
unsigned u = 4294967295u; /* UMax */ 
int tu = (int) u;
printf("u = %u, tu = %d\n", u, tu);
```

在一台采用补码的机器上，上述代码会产生如下输出：

```c
u=4294967295, tu= -1
```

从图 2-14 我们可以看到，对于 32 位字长来说，无符号形式的 4294967295 (UMax32) 和补码形式的一 l 的位模式是完全一样的。将 unsigned 强制类型转换成 int，底层的位表示保持不变。

对于大多数语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是：数值可能会改变，但是位模式不变。让我们用更数学化的形式来描述这个规则。我们定义函数 U2B。和 T2B，它们将数值映射为无符号数和补码形式的位表示。也就是说，给定 O≤x≤ UMaxw 范围内的一个整数 x，函数 U2B (x）会给出 x 的唯一的 w 位无符号表示。相似地，当 x 满足 TMinw≤x≤ TMaxw，函数 T2B (x）会给出 x 的唯一的 w 位补码表示。

现在，将函数 T2U 定义为 T2Uw (x）二 B2U (T2B (x））。这个函数的输入是一个TMinw~ TMaxw 的数，结果得到一个 0~UMax 的值，这里两个数有相同的位模式，除了参数是无符号的，而结果是以补码表示的。类似地，对于 0~ UMaxw 之间的值 x，定义函数 U2T 为 U2T (x）二 B2T (U2B. (x））。生成一个数的无符号表示和 x 的补码表示相同。

继续我们前面的例子，从图 2-15 中，我们看到 T2U16（一 12345) =53191，并且 U2T16 (53191) =一 12345。也就是说，十六进制表示写作 0xCFC7 的 16 位位模式既是一 12345 的补码表示，又是 53191 的无符号表示。同时请注意 12345+53191=65536= 216。这个属性可以推广到给定位模式的两个数值（补码和无符号数）之间的关系。类似地，从图 2-14 我们看到 T2U32（一 1) =4294967295，并且 U2T32 (4294967295) =一 1。也就是说，无符号表示中的 UMax 有着和补码表示的一 1 相同的位模式。我们在这两个数之间也能看到这种关系：1+ UMaxw=2w。

接下来，我们看到函数 U2T 描述了从无符号数到补码的转换，而 T2U 描述的是补码到无符号的转换。这两个函数描述了在大多数语言实现中这两种数据类型之间的强制类型转换效果。

通过上述这些例子，我们可以看到给定位模式的补码与无符号数之间的关系可以表示为函数 T2U 的一个属性：

#### 原理：补码转换为无符号数

对满足 $TMin_w≤x≤TMax_w$ 的 x 有：(该属性可以通过比较公式（2.1) 和公式（2.3) 推导出来)
$$
T2U_w(x)=
\begin{cases}
x+2^w, &x<0\\
x, &x\ge0\
\end{cases}
$$

##### 推导证明：



#### 原理：无符号数转换为补码

对满足 $0≤u≤ UMax_w$ 的 u 有：
$$
U2T_w(u)=
\begin{cases}
u, &u\le TMax_w\\
u-2^w, &u\ge TMax_w\
\end{cases}
\tag{2.7}
$$

##### 推导证明：

设 $\vec u=U2B_w(u)$，这个位向量也是 $U2T_w(u)$ 的表示。公式 (2.1) 和公式 (2.3) 结合起来有
$$
U2T_w(u)=
-u_{w-1}2^w+u
\tag{2.8}
$$
在 $u$ 的无符号表示中，对公式（2.7) 的两种情况来说，位 uw-1 决定了 u 是否大于 $TМaxw=2^{w-1}-1$

图 2-18 说明了函数 $U2T$ 的行为。对于小的数 ($≤ TMax_w$)，从无符号到有符号的转换将保留数字的原值。对于大的数 ($>TMax_w$) ，数字将被转换为一个负数值。

![2-17](2-17.png)

总结一下，我们考虑无符号与补码表示之间互相转换的结果。

- 对于在范围 $0≤x≤ TMax_w$ 之内的值 x 而言，我们得到 $T2U_x(x)=x$ 和 $U2T_w(x) =x$

  。也就是说，在这个范围内的数字有相同的无符号和补码表示。

- 对于这个范围以外的数值，转换需要加上或者减去 $2^w$。例如，

  - 我们有 $T2U_w(-1)=-1+2^w= UMax_w$ —— 最靠近 0 的负数映射为最大的无符号数。
  - 在另一个极端，我们可以看到 $T2U_w(TMin_w)=-2^{w-1}+2^w=2^{w-1}= TMax_w+1$ ——最小的负数映射为一个刚好在补码的正数范围之外的无符号数。
  - 使用图 2-15 的示例，我们能看到 $T2U_{16}(-12345)=65563+-12345=53191$



### C 语言中的有符号数和无符号数

#### C 语言中 TMin 的写法



### 扩展一个数字的位表示

一个常见的运算是在不同字长的整数之间转换，同时又保持数值不变。当然，当目标数据类型太小以至于不能表示想要的值时，这根本就是不可能的。然而，从一个较小的数据类型转换到一个较大的类型，应该总是可能的。

要将一个无符号数转换为一个更大的数据类型，我们只要简单地在表示的开头添加。这种运算被称为**零扩展(zero extension)**。表示原理如下：

#### 原理：无符号数的零扩展

定义宽度为 $w$ 的位向量 $\vec u= [u_{w-1}, u_{w-2}, …, u_o]$和宽度为 $w'$ 的位向量 u'= $[0, …, 0, u_{w-1}, u_{w-2}, …, u_0]$，其中 $w'>w$。则 $B2Uw(\vec u) =B2U_{w'}(\vec u')$。

按照公式（2.1)，该原理可以看作是直接遵循了无符号数编码的定义。

要将一个补码数字转换为一个更大的数据类型，可以执行一个符号扩展 (sign extension)，在表示中添加最高有效位的值，表示为如下原理。我们用蓝色标出符号位 $x_{w-i}$ 来突出它在符号扩展中的角色。

#### 原理：补码数的符号扩展

定义宽度为 $w$ 的位向量 $\vec x=[x_{w-1}, x_{w-2}, …, x_0]$ 和宽度为 $w$ 的位向量 $\vec x'= [x_{w-1}, …, x_{w-1}, x_{w-2}, …, x_0]$，其中 $w'>w$。则 $B2T_w(\vec x)=B2T_{w'}(\vec x')$。





有了这个直觉，我们现在可以展示保持补码值的符号扩展。

##### 推导：补码数值的符号扩展

令 $w'=w+k$，我们想要证明的是 
$$
B2T_{w+k}([x_{w-1},...,x_{w-1},x_{w-1},x_{w-2},...,x_0])=B2T_w([x_{w-1},x_{w-2},...,x_0])
$$
(k 次 $x_{w-1}$)

下面的证明是对 k 进行归纳。也就是说，如果我们能够证明符号扩展一位保持了数值不变，那么符号扩展任意位都能保持这种属性。因此，证明的任务就变为了：
$$
B2T_{w+1}([x_{w-1},x_{w-1},x_{w-2},...,x_0])=B2T_w([x_{w-1},x_{w-2},...,x_0])
$$
用等式（2.3) 展开左边的表达式，得到：
$$
\begin{aligned}
B2T_{w+1}([x_{w-1},x_{w-1},x_{w-2},...,x_0])
& = -x_{w-1}2^w +\sum\limits_{i=0}^{w-1}x_i2^i \\
& = -x_{w-1}2^w+x_{w-1}2^{w-1}+\sum\limits_{i=0}^{w-2}x_i2^i \\
& = -x_{w-1}(2^w-2^{w-1})+\sum\limits_{i=0}^{w-2}x_i2^i \\
& = -x_{w-1}2^{w-1} + \sum\limits_{i=0}^{w-2}x_i2^i \\
& = B2T_w([x_{w-1},x_{w-2},..x_0])
\end{aligned}
$$
我们使用的关键属性是 $2^w-2^{w-1}=2^{w-1}$。因此，加上一个权值为 $-2^w$ 的位，和将一个权值为 $-2^{w-1}$ 的位转换为一个权值为 $2^{w-1}$ 的位，这两项运算的综合效果就会保持原始的数值。



### 截断数字

假设我们不用额外的位来扩展一个数值，而是减少表示一个数字的位数。例如下面代码中这种情况：

```c
int x = 53191;
short sx  (short) x; /*-12345 */ 
int y sx; /*-12345*/
```

当我们把 x 强制类型转换为 short 时，我们就将 32 位的 int 截断为了 16 位的 short int。就像我们看到的那样，有符号数到无符号数的隐式强制类型转换导致了某些非直观的行为。而这些非直观的特性经常导致程序错误，并且这种包含隐式强制类型转换的细微差别的错误很难被发现。因为这种强制类型转换是在代码中没有明确指示的情况下发生的，程序员经常忽视了它的影响。

下面两个练习题说明了某些由于隐式强制类型转换和无符号数据类型造成的细微的错误。

#### 原理：截断无符号数

令 $\vec x$ 等于位向量 $[x_{w-1}, x_{w-2}, …, x_0]$，而 $\vec x'$ 是将其截断为 k 位的结果： $\vec x=[x_{k-1}, x_{k-2}, …, x_0】$。令 $x=B2U_w(\vec x), x'=B2U_k(\vec x')$。则 $x'=x\mod2^k$。

该原理背后的直觉就是所有被截去的位其权重形式都为 $2^i$，其中 $i≥k$，因此，每一个权在取模操作下结果都为零。可用如下推导表示：

##### 推导：截断无符号数

通过对等式（2.1) 应用取模运算就可以看到：
$$
\begin{aligned}
B2U_w([x_{w-1},x_{w-2},...,x_0])\mod2^k 
& = [\sum\limits_{i=0}^{w-1}x_i2^i]\mod2^k \\ 
& = [\sum\limits_{i=0}^{k-1}x_i2^i]\mod2^k \\ 
& = \sum\limits_{i=0}^{k-1}x_i2^i \\ 
& = B2K_k([x_{k-1},x_{k-2},...,x_0]) \\ 

\end{aligned}
$$

在这段推导中，我们利用了属性：对于任何 $i≥k,2^i \mod2^k=0$。

补码截断也具有相似的属性，只不过要将最高位转换为符号位：

#### 原理：截断补码数值

令 $\vec x$ 等于位向量 $[x_{w-1}, x_{w-2},…, x_0]$。而 $\vec x'$ 是将其截断为 $k$ 位的结果：

$\vec x'=[x_{k-1}, x_{k-2},…, x_0]$ 。令 $x=B2U_w (\vec x), x'=B2T_k(\vec x') $。则 $x'=U2T_k(x \mod2^k)$。

在这个公式中，xmod2k 将是 0 到 2k 一 1 之间的一个数。对其应用函数 U2Tk 产生的效果是把最高有效位 xk-1 的权重从 2k-1 转变为一 2k-1。举例来看，将数值 x=53191 从 int 转换为 short。由于 216=65536≥x，我们有 xmod216=x。但是，当我们把这个数转换为 16 位的补码时，我们得到 $x'=53191 - 65536= -12345$.

##### 推导：截断补码数值

使用与无符号数截断相同的参数，则有
$$
B2U_w([x_{w-1},x_{w-2},...,x_0])\mod 2^k=B2U_k[x_{k-1}, x_{k-2},...,x_0]
$$

也就是，$x \mod2k$ 能够被一个位级表示为 $[x_{k-1}, x_{k-2}, …, x_0]$ 的无符号数表示。将其转换为补码数则有 $x'=U2T_k(x\mod2^k)$。

总而言之，无符号数的截断结果是：
$$
B2U_k[x_{k-1}, x_{k-2},...,x_0]=B2U_w([x_{w-1},x_{w-2},...,x_0])\mod 2^k
$$

而补码数字的截断结果是：
$$
B2T_k[x_{k-1}, x_{k-2},...,x_0]=U2T_k(B2U_w([x_{w-1},x_{w-2},...,x_0])\mod 2^k)
$$



### 关于有符号数和无符号数的建议

#### 函数 getpeername 的安全漏洞



## 3 整数运算

### 3.1 无符号加法

考虑两个非负整数 x 和 y，满足 $0≤x$, $y<2^w$。每个数都能表示为 w 位无符号数字。

然而，如果计算它们的和，我们就有一个可能的范围 $0≤x+y≤2^{w+1}-2$。表示这个和可能需要 $w+1$ 位。例如，图 2-21 展示了当 x 和 y 有 4 位表示时，函数 $x+y$ 的坐标图。参数（显示在水平轴上）取值范围为 0~15，但是和的取值范围为 0~30。

函数的形状是一个有坡度的平面（在两个维度上，函数都是线性的）。

如果保持和为一个 w+1 位的数字，并且把它加上另外一个数值，我们可能需要 w+2 个位，以此类推。这种持续的<u>“字长膨胀”</u>意味着，要想完整地表示算术运算的结果，我们不能对字长做任何限制。

Lisp 实际就支持无限精度的运算，允许任意的机器的内存限制之内的整数运算。更常见的是，编程语言支持固定精度的运算，因此像“加法”和“乘法”这样的运算不同于它们在整数上的相应运算。

让我们为参数 x 和 y 定义运算$+^u_w$ ，其中 $0≤x, y<2^w$，该操作是把整数和 $x+y$ 截断为位 w 得到的结果，再把这个结果看做是一个无符号数。这可以被视为一种形式的模运算，对 $x+y$ 的位级表示，简单丢弃任何权重大于 $2^{w-1}$ 的位就可以计算出和模 $2^w$。比如，考虑一个 4 位数字表示，x=9 和 y=12 的位表示分别为 [1001] 和[1100]。它们的和是 21，5 位的表示为 [10101]。但是如果丢弃最高位，我们就得到 [0101]，也就是说，十进制值的 5。这就和值 $21\mod16=5$ 一致。

可以把操作 $+^u_w$ 描述为：

#### 原理：无符号数加法

对满足 $0≤x,y<2^w$ 的 x 和 y 有：
$$
x+^u_wy=
\begin{cases}
x+y, &x+y<2^w, 正常\\ 
x+y-2^w, &2^w\le x+y<2^{w-1}, 溢出\\
\end{cases}
\tag{2.11}
$$

##### 推导：无符号数加法

当执行 C 程序时，不会将溢出作为错误而发信号。不过有的时候，我们可能希望判定是否发生了溢出。

#### 原理：检测无符号数加法中的溢出

对在范围 $0≤x,y≤UMax_w$ 中的 x 和 y，令 $s≐x+^u_wy$。则对计算 s，当且仅当 $s<x$（或者等价地 $s<y$）时，发生了溢出。

作为说明，在前面的示例中，我们看到 $9+^u_412=5$。由于 5 <9，我们可以看出发生了溢出。

##### 推导：检测无符号数加法中的溢出

通过观察发现 $x+y≥x$，因此如果 s 没有溢出，我们能够肯定 $s≥x$。另一方面，如果 s 确实溢出了，我们就有 $s=x+y-2^w$。假设 $y<2^w$，我们就有 $y-2^w<0$，因此 $s=x+(y-2^w)<x$。

模数加法形成了一种数学结构，称为**阿贝尔群(Abelian group)**，也就说，它是可交换的和可结合的。它有一个单位元 0，并且每个元素有一个加法逆元。让我们考虑 w 位的无符号数的集合，执行加法运算十 u。对于每个值 x，必然有某个值一 x 满足一 ux+ux=0。该加法的逆操作可以表述如下：

#### 原理：无符号数求反

对满足 0≤x <2“的任意 x，其 w 位的无符号逆元一 x 由下式给出：

该结果可以很容易地通过案例分析推导出来：

##### 推导：无符号数求反

当 x=0 时，加法逆元显然是 0。对于 x>0, 考虑值 2w 一 x。我们观察到这个数字在 0 <2w 一 x <2w 范围之内，并且（x 十 2“一 x) mod2w=2“mod2w=0。因此，它就是 x 在十下的逆元。

### 3.2 补码加法

### 3.3 补码的非

### 3.4 无符号乘法

### 3.5 补码乘法

### 3.6 乘以常数

### 3.7 关于整数运算的思考



## 4 浮点数

浮点数表示对形如 $V=x\times2^y$ 的有理数进行编码。它对执行...很有用

- 涉及非常大的数字 $(|V|>>0)$，
- 非常接近 0 $(|V| << 1)$ 的数字，
- 以及更普遍的作为实数运算的近似值的计算

### 二进制小数

十进制表示法：$d_md_{m-1}...d_1d_0·d_{-1}d_{-2}...d{-n}$, 其中每个十进制数 $d_i$ 的取值范围是 $0\sim 9$, 这个表达描述的数值 $d$ 定义如下：

$$
\begin{align} d=\sum_{i=-n}^{m}10^i\times d_i\end{align}
$$
数字权的定义与十进制小数点符号 $.$ 相关

类似，考虑一个形如 $b_mb_{m-1}...b_1b_0·b_{-1}b{-2}...b_{-n-1}b_{-n}$ 的表示法，其中每个二进制数字，或者称为位，$b_i$ 的取值范围是 0 和 1，如图 2-31，这种方法表示的数 b 定义如下

$$
\begin{align} b=\sum_{i=-n}^{m}2^i\times b_i\end{align}
$$

![2-31](/Users/kedae/Desktop/zennlyu.github.io/hexo/source/_posts/15-213-Ch02_Bits/2-31.png)

符号 $·$ 表示二进制的点，点左边位的权是 2 的正幂，右边位的权是 2 的负幂

形如 $0.11...1_2$ 的数表示的刚好小于 1 的数，我们可以用简单的表达法 $1.0-\varepsilon$ 来表示这样的数值

小数的二进制只能表示那些能够被写成 $x\times2^y$ 的数，其他只能近似表示。只能近似地表示它，增加二进制表示的长度可以提高表示的精度



### IEEE 浮点表示

IEEE 浮点标准用 $V=(-1)^s\times M\times 2^E$ 的形式来表示一个数：

- sign 符号
- significand 尾数
- exponent 阶码

将浮点数的位表示划分为三个字段，分别对这些值进行编码：

- 一个单独的符号位 $s$ 直接编码符号
- $k$ 位的阶码字段 $exp=e_{k-1}...e_1e_0$ 编码阶段 $E$
- $n$ 位小数字段 $frac=f_{n-1}...f_1f_0$ 编码尾数 $M$ ，但是编码出来的值也依赖于阶码字段的值是否等于 0

图 2-32 给出了将这三个字段装进字中两种最常见的格式。

- 在单精度浮点格式 $float$，$s$, $exp$ 和 $frac$ 字段分别为1位，$k=8$ 和 $n=23$ 位，得到一个 32 位的表示
- 在双精度浮点格式 $double$，$s$, $exp$ 和 $frac$ 字段分别为1位，$k=11$ 和 $n=52$ 位，得到一个 64 位的表示

给定位表示，根据 $exp$ 的值，被编码的值可以分成三种不同的情况（最后一种情况有两个变种）

### 数字示例

### 舍入

### 浮点运算

### C 语言中的浮点数

