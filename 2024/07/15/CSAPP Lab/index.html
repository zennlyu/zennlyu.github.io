<!DOCTYPE html>
<html lang='en'>

<head>
  <meta name="generator" content="Hexo 6.3.0">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://fastly.jsdelivr.net'>
  <link rel="preconnect" href="https://fastly.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  <title>CSAPP Datalab - zennlyu</title>

  
    <meta name="description" content="Datalab 笔记旧版本bitAnd(x,y)12345678910&#x2F;*  * bitAnd - x&amp;y using only ~ and |  *   Example: bitAnd(6, 5) &#x3D; 4 *   Legal ops: ~ | *   Max ops: 8 *   Rating: 1 *&#x2F;int bitAnd(int x, int y) &amp;#123;  return ~(">
<meta property="og:type" content="article">
<meta property="og:title" content="CSAPP Datalab">
<meta property="og:url" content="http://example.com/2024/07/15/CSAPP%20Lab/index.html">
<meta property="og:site_name" content="zennlyu">
<meta property="og:description" content="Datalab 笔记旧版本bitAnd(x,y)12345678910&#x2F;*  * bitAnd - x&amp;y using only ~ and |  *   Example: bitAnd(6, 5) &#x3D; 4 *   Legal ops: ~ | *   Max ops: 8 *   Rating: 1 *&#x2F;int bitAnd(int x, int y) &amp;#123;  return ~(">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2024/07/15/CSAPP%20Lab/2-14.png">
<meta property="og:image" content="http://example.com/2024/07/15/CSAPP%20Lab/float.png">
<meta property="og:image" content="http://example.com/2024/07/15/CSAPP%20Lab/2-32.png">
<meta property="og:image" content="http://example.com/2024/07/15/CSAPP%20Lab/2-33.png">
<meta property="og:image" content="http://example.com/2024/07/15/CSAPP%20Lab/prac.png">
<meta property="article:published_time" content="2024-07-15T03:58:26.019Z">
<meta property="article:modified_time" content="2024-07-16T04:09:40.948Z">
<meta property="article:author" content="zennlyu">
<meta property="article:tag" content="CSAPP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/07/15/CSAPP%20Lab/2-14.png">
  
  

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  

  


  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    


<header class="header">

<div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://fastly.jsdelivr.net/gh/cdn-x/placeholder@1.0.2/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="https://i.imgtg.com/2022/07/09/eTtVL.jpg" onerror="javascript:this.classList.add('error');this.src='https://fastly.jsdelivr.net/gh/cdn-x/placeholder@1.0.1/image/2659360.svg';"></a><a class="title" href="/"><div class="main">zennlyu</div></a></div>
<nav class="menu dis-select"><a class="nav-item active" href="/">Blog</a><a class="nav-item" href="/more/">更多</a></nav></header>

<div class="widgets">

<div class="widget-wrap single" id="toc"><div class="widget-header cap dis-select"><span class="name">TOC</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A7%E7%89%88%E6%9C%AC"><span class="toc-text">旧版本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bitAnd-x-y"><span class="toc-text">bitAnd(x,y)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getByte"><span class="toc-text">getByte</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%A1%A5%E7%A0%81"><span class="toc-text">2.补码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="toc-text">3.浮点数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B0%E7%89%88%E6%9C%AC"><span class="toc-text">新版本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bitXor-x-y-%E5%8F%AA%E4%BD%BF%E7%94%A8-%E5%92%8C-amp-%E5%AE%9E%E7%8E%B0"><span class="toc-text">bitXor(x,y) 只使用 ~ 和 &amp; 实现 ^</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tmin-%E8%BF%94%E5%9B%9E%E6%9C%80%E5%B0%8F%E8%A1%A5%E7%A0%81"><span class="toc-text">tmin() 返回最小补码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#isTmax-x-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E8%A1%A5%E7%A0%81%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-text">isTmax(x) 判断是否是补码最大值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#allOddBits-x-%E5%88%A4%E6%96%AD%E8%A1%A5%E7%A0%81%E6%89%80%E6%9C%89%E5%A5%87%E6%95%B0%E4%BD%8D%E6%98%AF%E5%90%A6%E9%83%BD%E6%98%AF1"><span class="toc-text">allOddBits(x) 判断补码所有奇数位是否都是1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#negate-x-%E4%B8%8D%E4%BD%BF%E7%94%A8%E8%B4%9F%E5%8F%B7-%E5%AE%9E%E7%8E%B0-x"><span class="toc-text">negate(x) 不使用负号 - 实现 -x</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#isAsciiDigit-x-%E5%88%A4%E6%96%AD-x-%E6%98%AF%E5%90%A6%E6%98%AF-ASCII-%E7%A0%81"><span class="toc-text">isAsciiDigit(x) 判断 x 是否是 ASCII 码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#conditional-x-y-z-%E7%B1%BB%E4%BC%BC%E4%BA%8E-C-%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84-x-y-z"><span class="toc-text">conditional(x, y, z) 类似于 C 语言中的 x?y:z</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#isLessOrEqual-x-y-x-lt-y"><span class="toc-text">isLessOrEqual(x,y) x&lt;&#x3D;y</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#logicalNeg-x-%E8%AE%A1%E7%AE%97-x-%E4%B8%8D%E7%94%A8-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">logicalNeg(x) 计算 !x (不用 ! 运算符)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#howManyBits-x-%E8%AE%A1%E7%AE%97%E8%A1%A8%E8%BE%BE-x-%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%91%E4%BD%8D%E6%95%B0"><span class="toc-text">howManyBits(x) 计算表达 x 所需的最少位数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#floatScale2-uf-%E8%AE%A1%E7%AE%97-2-0-uf"><span class="toc-text">floatScale2(uf) 计算 2.0*uf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#floatFloat2Int-uf-%E8%AE%A1%E7%AE%97-int-f"><span class="toc-text">floatFloat2Int(uf) 计算 (int) f</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#floatPower2-x-%E8%AE%A1%E7%AE%97-2-0%E7%9A%84x%E6%AC%A1%E6%96%B9"><span class="toc-text">floatPower2(x) 计算 2.0的x次方</span></a></li></ol></li></ol></div></div></div>


</div>


    </aside>
    <div class='l_main'>
      

      


<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" href="/">Home</a><span class="sep"></span><a class="cap breadcrumb" href="/">Blog</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/CSAPP/">CSAPP</a></div><div id="post-meta">Posted on&nbsp;<time datetime="2024-07-15T03:58:26.019Z">2024-07-15</time></div></div>

<article class='content md post'>
<h1 class="article-title"><span>CSAPP Datalab</span></h1>
<h1 id="Datalab-笔记"><a href="#Datalab-笔记" class="headerlink" title="Datalab 笔记"></a>Datalab 笔记</h1><h2 id="旧版本"><a href="#旧版本" class="headerlink" title="旧版本"></a>旧版本</h2><h3 id="bitAnd-x-y"><a href="#bitAnd-x-y" class="headerlink" title="bitAnd(x,y)"></a>bitAnd(x,y)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bitAnd - x&amp;y using only ~ and | </span></span><br><span class="line"><span class="comment"> *   Example: bitAnd(6, 5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ |</span></span><br><span class="line"><span class="comment"> *   Max ops: 8</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitAnd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ~((~x)|(~y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以参考<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BE%B7%E6%91%A9%E6%A0%B9%E5%AE%9A%E5%BE%8B">德摩根定律</a></p>
<h3 id="getByte"><a href="#getByte" class="headerlink" title="getByte"></a>getByte</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * getByte - Extract byte n from word x</span></span><br><span class="line"><span class="comment"> *   Bytes numbered from 0 (LSB) to 3 (MSB)</span></span><br><span class="line"><span class="comment"> *   Examples: getByte(0x12345678,1) = 0x56</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 6</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getByte</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">int</span> mask=<span class="number">0xff</span>;</span><br><span class="line">  <span class="keyword">return</span> (x&gt;&gt;(n&lt;&lt;<span class="number">3</span>))&amp;mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二题是从 x 中提取出第 i 个字节（i=0,1，2,3），方法就是将那个字节移位至最低位，然后用屏蔽码 <code>0xff</code> 提取就可以了</p>
<p>3.logicalShift</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalShift - shift x to the right by n, using a logical shift</span></span><br><span class="line"><span class="comment"> *   Can assume that 0 &lt;= n &lt;= 31</span></span><br><span class="line"><span class="comment"> *   Examples: logicalShift(0x87654321,4) = 0x08765432</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 20</span></span><br><span class="line"><span class="comment"> *   Rating: 3 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">logicalShift</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">int</span> mask=((<span class="number">0x1</span>&lt;&lt;(<span class="number">32</span>+~n))+~<span class="number">0</span>)|(<span class="number">0x1</span>&lt;&lt;(<span class="number">32</span>+~n));</span><br><span class="line">  <span class="keyword">return</span> (x&gt;&gt;n)&amp;mask;</span><br><span class="line"><span class="comment">/*  int c=((0x1&lt;&lt;31&gt;&gt;31)^0x1)&lt;&lt;31;</span></span><br><span class="line"><span class="comment">  return ((x&gt;&gt;n)^(c&gt;&gt;n)); it&#x27;s wrong.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*return ~((~x)&gt;&gt;n); it&#x27;s wrong.</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三题要求实现逻辑右移，对于有符号的 <code>int</code> ，C 语言默认的移位方式是算术右移，就是右移时在高位扩展符号位，这里我们需要扩展的符号位都设置为 0 ,可以构造一个屏蔽码屏蔽 <code>x&gt;&gt;n</code> 中的非扩展的位，用 &amp; 实现目的。<br>但这里要注意 C 语言对移位位数超出自身长度的行为是未定义的，因此在这里构造屏蔽码时不能使得移位位数超过了32或是小于0，我这段代码为了避免这种情况的发生，将屏蔽码分了最高位和其他位两部分构造，直接使用 <code>((0x1&lt;&lt;(33+~n))+~0)</code> 构造的屏蔽码在 n=0 将会无法确定。<br>这里 <code>32+~n</code> 表示了 31-n ，可以由补码的运算性质 <code>-x=~x+1</code> 得到，同时这里我在注释里写了两个我最初写的 bug 。      </p>
<p>4.bitCount</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * bitCount - returns count of number of 1&#x27;s in word</span></span><br><span class="line"><span class="comment"> *   Examples: bitCount(5) = 2, bitCount(7) = 3</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 40</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitCount</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> _mask1=(<span class="number">0x55</span>)|((<span class="number">0x55</span>)&lt;&lt;<span class="number">8</span>);</span><br><span class="line">  <span class="type">int</span> _mask2=(<span class="number">0x33</span>)|((<span class="number">0x33</span>)&lt;&lt;<span class="number">8</span>);</span><br><span class="line">  <span class="type">int</span> _mask3=(<span class="number">0x0f</span>)|((<span class="number">0x0f</span>)&lt;&lt;<span class="number">8</span>);</span><br><span class="line">  <span class="type">int</span> mask1=(_mask1)|(_mask1&lt;&lt;<span class="number">16</span>);</span><br><span class="line">  <span class="type">int</span> mask2=(_mask2)|(_mask2&lt;&lt;<span class="number">16</span>);</span><br><span class="line">  <span class="type">int</span> mask3=(_mask3)|(_mask3&lt;&lt;<span class="number">16</span>);</span><br><span class="line">  <span class="type">int</span> mask4=(<span class="number">0xff</span>)|(<span class="number">0xff</span>&lt;&lt;<span class="number">16</span>);</span><br><span class="line">  <span class="type">int</span> mask5=(<span class="number">0xff</span>)|(<span class="number">0xff</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">  <span class="type">int</span> ans=(x&amp;mask1)+((x&gt;&gt;<span class="number">1</span>)&amp;mask1);</span><br><span class="line">  ans=(ans&amp;mask2)+((ans&gt;&gt;<span class="number">2</span>)&amp;mask2);</span><br><span class="line">  ans=(ans&amp;mask3)+((ans&gt;&gt;<span class="number">4</span>)&amp;mask3);</span><br><span class="line">  ans=(ans&amp;mask4)+((ans&gt;&gt;<span class="number">8</span>)&amp;mask4);</span><br><span class="line">  ans=(ans&amp;mask5)+((ans&gt;&gt;<span class="number">16</span>)&amp;mask5);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这题好难T_T，应该是这个 lab 里最难的了吧；<br>题目意思就是要统计一个32位的 <code>int</code> 里的 <code>1</code> 的个数，但是只能使用40个操作符，直接扫一遍字的话操作符就大大超过规定数了；<br>这里构造了五个常数，分别是 <code>0x55555555，0x33333333，0x0f0f0f0f，0x00ff00ff，0x0000ffff</code>，就是分别间隔了1个0,2个0,4个0,8个0和16个0,利用这五个常数就能依次计算出五个值，第一个值每两位的值为 x 的对应的两个位的和（即这两位中 <code>1</code> 的数目），第二个值每四位是第一个值对应的四位中两个两位的和（即原 x 中 <code>1</code>的数目），依次类推最后一个值就是结果了；<br>怎么理解呢，可以看到这里构造的五个常数的间隔可以刚好使得只提取 n 位，移位之后再提取相邻 n 位（n=1,2,4,8,16），并且（考虑最大值可知）这两个 n 位加和后不会超出 n 位，使得 x 中的 <code>1</code> 一步步加和成最终的结果，可以举一个例子，若要求 1001 中 <code>1</code> 的数目，用<code>(1001&amp;0101)+((1001&gt;&gt;1)&amp;0101)</code>,就能将每相邻一位加和成一个两位，成 0101，再用<code>(0101&amp;0011)+((0101&gt;&gt;2)&amp;0011)</code>，就将每两位加和了，得到 0010 ,就是最终的结果。      </p>
<p>5.bang</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bang - Compute !x without using !</span></span><br><span class="line"><span class="comment"> *   Examples: bang(3) = 0, bang(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bang</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  x=(x&gt;&gt;<span class="number">16</span>)|x;</span><br><span class="line">  x=(x&gt;&gt;<span class="number">8</span>)|x;</span><br><span class="line">  x=(x&gt;&gt;<span class="number">4</span>)|x;</span><br><span class="line">  x=(x&gt;&gt;<span class="number">2</span>)|x;</span><br><span class="line">  x=(x&gt;&gt;<span class="number">1</span>)|x;</span><br><span class="line">  <span class="keyword">return</span> ~x&amp;<span class="number">0x1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这题要求仅用规定的操作符来实现！运算，对 0 运算就得到 1,对非 0 就得到 0；也就是如果 x 的位中含有 1 就返回 0 ,这里运用移位后取或将 x 中的位一步步「折叠」 到了第一位上，然后判断第一位就可以了，这种「折叠」的方法很有趣，值得一看：）  </p>
<h2 id="2-补码"><a href="#2-补码" class="headerlink" title="2.补码"></a>2.补码</h2><p>6.tmin</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tmin - return minimum two&#x27;s complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0x1</span>&lt;&lt;<span class="number">31</span>;<span class="comment">/*tmin==~tmax*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这题返回补码最小值，注意到 <code>tmin==~tmax</code>，补码负数表示部分和正数是不对称的，最小值的绝对值是最大值的绝对值加1。    </p>
<p>7.fitsBits</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * fitsBits - return 1 if x can be represented as an </span></span><br><span class="line"><span class="comment"> *  n-bit, two&#x27;s complement integer.</span></span><br><span class="line"><span class="comment"> *   1 &lt;= n &lt;= 32</span></span><br><span class="line"><span class="comment"> *   Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fitsBits</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">int</span> c=<span class="number">33</span>+~n;</span><br><span class="line">  <span class="type">int</span> t=(x&lt;&lt;c)&gt;&gt;c;</span><br><span class="line">  <span class="keyword">return</span> !(x^t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这题题目意思是判断 x 能否用一个 n 位的补码表示，能的话就返回 1,开始我没看懂题目…举个例子，101 是不能用 3 位补码表示的，因为 3 位最高位是符号位，最大只能表示 011,注意到这里 x 是32位的，不能直接右移的；<br>要用 n 位的补码表示，x 只能是两种情况： <code>00…0|0|(n-1)位</code> 或是 <code>11…1|1|(n-1)位</code> ，这样 32 位的补码才会与 n 位的补码值相同，这里的方法就是将 x 左移（32-n）再右移回去，这样就能得到那两种情况的值，再判断这样操作之后是否与原来的 x 相等，就解决问题了；<br>这里由补码性质，<code>33+~n</code> 等于 <code>32-n</code> 。      </p>
<p>8.divpwr2</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * divpwr2 - Compute x/(2^n), for 0 &lt;= n &lt;= 30</span></span><br><span class="line"><span class="comment"> *  Round toward zero</span></span><br><span class="line"><span class="comment"> *   Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">divpwr2</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">int</span> bias=(x&gt;&gt;<span class="number">31</span>)&amp;((<span class="number">0x1</span>&lt;&lt;n)+~<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (x+bias)&gt;&gt;n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这题计算 x/(2^n) ，注意不能直接右移，直接右移是向下舍入的，题目要求是向零舍入，也就是正数向下舍入，负数向上舍入，这里参照 CS:APP 书上的做法，给负数加上一个偏正的因子 <code>(0x1&lt;&lt;n)+~0)</code> ，判断负数直接看符号位。    </p>
<p>9.negate</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这题求 -x ，直接利用补码的性质 <code>-x=~x+1</code> 就可以了。   </p>
<p>10.isPositive</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isPositive - return 1 if x &gt; 0, return 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Example: isPositive(-1) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 8</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isPositive</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> !(!(x))&amp;!((x&gt;&gt;<span class="number">31</span>)&amp;(<span class="number">0x1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里判断是否是正数，直接判断符号位，但是注意要排除 0 的情况！   </p>
<p>11.isLessOrEqual</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="type">int</span> val=!!((x+~y)&gt;&gt;<span class="number">31</span>);</span><br><span class="line">  x=x&gt;&gt;<span class="number">31</span>;</span><br><span class="line">  y=y&gt;&gt;<span class="number">31</span>;</span><br><span class="line">  <span class="keyword">return</span> (!!x|!y)&amp;((!!x&amp;!y)|(val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这题比较两个数的大小，要求判断第一个数是否小于等于第二个数，这里考虑做减法然后判断符号，注意要考虑溢出的情况，这里 <code>((x+~y))</code> 表示了 <code>x-y-1</code> ，若其结果为负，则 x &lt;= y ;<br>这里先判断 x 与 y 的符号，如果 x 为负，y 为正直接返回 1 ,如果 x 为正，y 为正，直接返回 0；然后就是全正数和全负数的减法，这样不会溢出。   </p>
<p>12.ilog2</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ilog2 - return floor(log base 2 of x), where x &gt; 0</span></span><br><span class="line"><span class="comment"> *   Example: ilog2(16) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 90</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ilog2</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">  ans=(!!(x&gt;&gt;(<span class="number">16</span>)))&lt;&lt;<span class="number">4</span>;</span><br><span class="line">  ans=ans+((!!(x&gt;&gt;(<span class="number">8</span>+ans)))&lt;&lt;<span class="number">3</span>);</span><br><span class="line">  ans=ans+((!!(x&gt;&gt;(<span class="number">4</span>+ans)))&lt;&lt;<span class="number">2</span>);</span><br><span class="line">  ans=ans+((!!(x&gt;&gt;(<span class="number">2</span>+ans)))&lt;&lt;<span class="number">1</span>);</span><br><span class="line">  ans=ans+((!!(x&gt;&gt;(<span class="number">1</span>+ans)))&lt;&lt;<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这题求 x 以 2 为底的对数，解法有点难想到，注意到 32 位数的对数最大也不会超过 32,可以写成是 <code>16*a+8*b+4*c+2*d+e</code> 这里 a，b，c，d，e 都是 0 或 1，然后通过向右移 16 位就可以判断符号就可以得到 a ，右移 16*a+8 位可得到 b，以此类推得到其他位。   </p>
<h2 id="3-浮点数"><a href="#3-浮点数" class="headerlink" title="3.浮点数"></a>3.浮点数</h2><p>以下三题是关于浮点数的，可以使用任何操作符和分支语句。   </p>
<p>13.float_neg</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * float_neg - Return bit-level equivalent of expression -f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representations of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">float_neg</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="type">int</span> c=<span class="number">0x00ffffff</span>;</span><br><span class="line">  <span class="keyword">if</span>(((uf&lt;&lt;<span class="number">1</span>)^(<span class="number">0xffffffff</span>))&lt;c)&#123;</span><br><span class="line">    <span class="keyword">return</span> uf;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uf^(<span class="number">0x80000000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这题计算 -f ，f 是浮点数，这里直接改浮点数的符号位，但是注意要单独考虑 NaN 的结果。      </p>
<p>14.float_i2f</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * float_i2f - Return bit-level equivalent of expression (float) x</span></span><br><span class="line"><span class="comment"> *   Result is returned as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">float_i2f</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> n=<span class="number">0xffffffff</span>;</span><br><span class="line">  <span class="type">int</span> e=<span class="number">0</span>; <span class="comment">/* exp */</span></span><br><span class="line">  <span class="type">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> tmp2=<span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> cp=<span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> cp2=<span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> sign=x&amp;<span class="number">0x80000000</span>; <span class="comment">/* 0x80000000 or 0x0 */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(x==<span class="number">0x80000000</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0xcf000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span>(x==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(sign)&#123;</span><br><span class="line">      x=-x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  x=x&amp;<span class="number">0x7fffffff</span>; <span class="comment">/* remove sign */</span></span><br><span class="line">  tmp=x;</span><br><span class="line">  <span class="keyword">while</span>(tmp)&#123;</span><br><span class="line">    tmp=tmp&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    n++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  x=x-(<span class="number">0x1</span>&lt;&lt;n); <span class="comment">/* remove highest bit */</span></span><br><span class="line">  <span class="keyword">if</span>(n&lt;<span class="number">24</span>)&#123;</span><br><span class="line">    x=x&lt;&lt;(<span class="number">23</span>-n);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    tmp2=x&gt;&gt;(n<span class="number">-23</span>);</span><br><span class="line">    cp2=<span class="number">0x1</span>&lt;&lt;(n<span class="number">-24</span>);</span><br><span class="line">    cp=x&amp;((cp2&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(cp&lt;cp2)&#123;</span><br><span class="line">      x=tmp2;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(tmp2==<span class="number">0x7fffff</span>)&#123;</span><br><span class="line">        x=<span class="number">0</span>;</span><br><span class="line">        n++;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cp==cp2)&#123;</span><br><span class="line">          x=((tmp2)&amp;<span class="number">0x1</span>)+tmp2;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          x=tmp2+<span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  e=(<span class="number">127</span>+n)&lt;&lt;<span class="number">23</span>;</span><br><span class="line">  <span class="keyword">return</span> sign|e|x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这题是将整型转化为浮点数的格式，坑点很多，耗时长。。<br>整体思路就是依次计算符号位，阶码值和小数字段，符号位可以直接移位提取，阶码值就是除了符号位外最高位的位数减 1 再加上偏差 127，小数字段可以移位（负数可以化为正数操作）获得，但这问题没这么简单，有很多坑点：<br>1.特殊值 0 化为浮点数后是非规格化的，单独考虑；<br>2.特殊值 0x80000000 是 2 的整数倍，小数部分用移位的话因为舍入问题会溢出，单独考虑；<br>3.要仔细考虑移位过程，左移还是右移能得到 23 位的小数部分；<br>4.注意舍入问题，这里需要仔仔细细地考虑清楚，默认使用向偶数舍入，就是舍去部分小于中间值舍弃，大于中间值进位，为中间值如 100 就向偶数舍入：就是看前一位，进位或舍弃总使得前一位为 0；<br>5.最后就是操作数目限制在 30 位，我最开始写完的代码有 42 个操作符，应该是算法太麻烦了。。写完最后要一步步简化操作符数目，控制中 30 以内，这里我为了减少操作符数目，写了些可读性很不高的表达式，还用了不少变量如 cp，cp2，简化这些耗了我很多时间。</p>
<p>15.float_twice</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * float_twice - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">float_twice</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="type">int</span> tmp=uf;</span><br><span class="line">  <span class="type">int</span> sign=((uf&gt;&gt;<span class="number">31</span>)&lt;&lt;<span class="number">31</span>); <span class="comment">/* 0x80000000 or 0x0 */</span></span><br><span class="line">  <span class="type">int</span> <span class="built_in">exp</span>=uf&amp;<span class="number">0x7f800000</span>;</span><br><span class="line">  <span class="type">int</span> f=uf&amp;<span class="number">0x7fffff</span>;</span><br><span class="line">  tmp=tmp&amp;<span class="number">0x7fffffff</span>; <span class="comment">/* remove sign */</span></span><br><span class="line">  <span class="keyword">if</span>((tmp&gt;&gt;<span class="number">23</span>)==<span class="number">0x0</span>)&#123;</span><br><span class="line">    tmp=tmp&lt;&lt;<span class="number">1</span>|sign;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((tmp&gt;&gt;<span class="number">23</span>)==<span class="number">0xff</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> uf;</span><br><span class="line">  &#125;  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((<span class="built_in">exp</span>&gt;&gt;<span class="number">23</span>)+<span class="number">1</span>==<span class="number">0xff</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> sign|<span class="number">0x7f800000</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> sign|(((<span class="built_in">exp</span>&gt;&gt;<span class="number">23</span>)+<span class="number">1</span>)&lt;&lt;<span class="number">23</span>)|f;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这题计算浮点数的两倍，无穷大和 NaN 时直接返回，然后分规格化和非规格化两种讨论：<br>规格化的情况，阶码值直接加 1 ，但是有个特殊情况就是加一后阶码为 255 时，应返回无穷大；<br>非规格化的情况，排除符号位左移一位就可以了，因为这时阶码值为 0 ,两倍就相当于小数字段左移一位，不用担心溢出的情况，溢出时阶码值加 1,小数字段左移一位，相当于整体左移了。</p>
<h2 id="新版本"><a href="#新版本" class="headerlink" title="新版本"></a>新版本</h2><h3 id="bitXor-x-y-只使用-和-amp-实现"><a href="#bitXor-x-y-只使用-和-amp-实现" class="headerlink" title="bitXor(x,y) 只使用 ~ 和 &amp; 实现 ^"></a>bitXor(x,y) 只使用 ~ 和 &amp; 实现 ^</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bitXor - x^y using only ~ and &amp; </span></span><br><span class="line"><span class="comment"> *   Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment"> *   Max ops: 14</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="comment">// 直接推公式，^可以使用~、&amp;和|表示，而|又可以用~和&amp;表示</span></span><br><span class="line">    <span class="keyword">return</span> ~(~x&amp;~y)&amp;~(x&amp;y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="tmin-返回最小补码"><a href="#tmin-返回最小补码" class="headerlink" title="tmin() 返回最小补码"></a>tmin() 返回最小补码</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/2024/07/15/CSAPP%20Lab/2-14.png" alt="2-14"></p>
<p>有符号数是用补码来表示的，Tmin表示最小补码数，对于1个字节大小的补码，最小补码数形式为1000 0000（最小的有符号数，符号位为1，其余都是0），C语言中int类型占4字节，即32位，所以对1左移31位来构造最小补码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tmin - return minimum two&#x27;s complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="isTmax-x-判断是否是补码最大值"><a href="#isTmax-x-判断是否是补码最大值" class="headerlink" title="isTmax(x) 判断是否是补码最大值"></a>isTmax(x) 判断是否是补码最大值</h3><p>函数功能是判断x是否是有符号数的最大值，也就是补码最大值，还是拿1个字节来看，最大补码数的形式为0111 1111，代码中的neg1是为了将-1单独判断出来，因为如果只使用return后面那句(!(~(x+1)^x))的话，会导致当x=-1的时候也会返回1，判断出现错误，而改变后的返回结果可以排除-1的干扰。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isTmax</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> neg1;</span><br><span class="line">  neg1 = !(~x); <span class="comment">// 如果x为-1, 则neg1为1，否则neg1为0，这里是为了排除-1的干扰</span></span><br><span class="line">  <span class="keyword">return</span> !((~(x+<span class="number">1</span>)^x)|neg1); <span class="comment">// 给x加1，再翻转，最后和自身取异或，如果x为Tmax，则返回1，否则返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="allOddBits-x-判断补码所有奇数位是否都是1"><a href="#allOddBits-x-判断补码所有奇数位是否都是1" class="headerlink" title="allOddBits(x) 判断补码所有奇数位是否都是1"></a>allOddBits(x) 判断补码所有奇数位是否都是1</h3><p>构造掩码操作即可，将掩码和x进行与操作，可以让x的奇数位置不变，而偶数位置变为0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class="line"><span class="comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 2  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">allOddBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> mask = (<span class="number">0xAA</span> &lt;&lt; <span class="number">8</span>) + <span class="number">0xAA</span>;</span><br><span class="line">  mask = (mask &lt;&lt; <span class="number">16</span>) + mask; <span class="comment">// 构造掩码</span></span><br><span class="line">  <span class="keyword">return</span> !((x &amp; mask) ^ mask); <span class="comment">// &amp;操作将x的奇数位取出，偶数位置0，之后再与掩码异或判断是否满足条件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="negate-x-不使用负号-实现-x"><a href="#negate-x-不使用负号-实现-x" class="headerlink" title="negate(x) 不使用负号 - 实现 -x"></a>negate(x) 不使用负号 - 实现 -x</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ~x + <span class="number">1</span>; <span class="comment">// 补码取相反数操作：按位取反再加一</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="isAsciiDigit-x-判断-x-是否是-ASCII-码"><a href="#isAsciiDigit-x-判断-x-是否是-ASCII-码" class="headerlink" title="isAsciiDigit(x) 判断 x 是否是 ASCII 码"></a>isAsciiDigit(x) 判断 x 是否是 ASCII 码</h3><p>通过上下界来判断输入的x是否在0x30~0x39的范围中，使用x分别加上界和下界，当x不在这个范围中时，通过判断符号位的变化来得出判断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> negative = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> lessthan = ~(negative | <span class="number">0x39</span>); <span class="comment">// 构造上界，如果超过，则符号位变为1</span></span><br><span class="line">  <span class="type">int</span> greatthan = (~(<span class="number">0x30</span>) + <span class="number">1</span>); <span class="comment">// 构造下界，如果不足，则符号位变为1</span></span><br><span class="line"></span><br><span class="line">  lessthan = negative &amp; (lessthan + x) &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  greatthan = negative &amp; (greatthan + x) &gt;&gt; <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> !(lessthan | greatthan); <span class="comment">// 判断符号位是否为1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="conditional-x-y-z-类似于-C-语言中的-x-y-z"><a href="#conditional-x-y-z-类似于-C-语言中的-x-y-z" class="headerlink" title="conditional(x, y, z) 类似于 C 语言中的 x?y:z"></a>conditional(x, y, z) 类似于 C 语言中的 x?y:z</h3><p>重点在于return语句，这个操作可以根据x的不同来返回不同的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z </span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">  x = !!x; <span class="comment">// 判断x是否为0，若x=0，则x赋值为0；若x不为0，则x赋值为1</span></span><br><span class="line">  x = ~x + <span class="number">1</span>; <span class="comment">// 得到x的补码，0的补码还是0，1的补码为-1(二进制序列全1)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (x&amp;y)|(~x&amp;z); <span class="comment">// 若x为0，则返回z；若x为1，则返回y</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="isLessOrEqual-x-y-x-lt-y"><a href="#isLessOrEqual-x-y-x-lt-y" class="headerlink" title="isLessOrEqual(x,y) x&lt;=y"></a>isLessOrEqual(x,y) x&lt;=y</h3><p>判断方法：如果x和y同符号，当x&lt;=y则返回1；或者如果x和y不同符号，那么当x&lt;0则返回1；其余情况返回0。<br>这里根据y-x的结果的符号来判断x和y的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="type">int</span> minusx = ~x + <span class="number">1</span>; <span class="comment">// 得到-x</span></span><br><span class="line">  <span class="type">int</span> result = y + minusx; <span class="comment">// 得到y - x</span></span><br><span class="line">  <span class="type">int</span> sign = (result &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>; <span class="comment">// 判断result的符号，如果y&gt;=x，则sign等于0，否则等于1</span></span><br><span class="line">  <span class="type">int</span> xsign = (x &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>; <span class="comment">// 取出x的符号</span></span><br><span class="line">  <span class="type">int</span> ysign = (y &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>; <span class="comment">// 取出y的符号</span></span><br><span class="line">  <span class="type">int</span> bitXor = xsign ^ ysign; <span class="comment">// 判断x和y符号是否一致</span></span><br><span class="line">  <span class="keyword">return</span> ((!bitXor)&amp;(!sign)) | ((bitXor&amp;xsign)); <span class="comment">// 要么x和y符号相同并且x&lt;=y，要么x和y符号不同并且x&lt;0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="logicalNeg-x-计算-x-不用-运算符"><a href="#logicalNeg-x-计算-x-不用-运算符" class="headerlink" title="logicalNeg(x) 计算 !x (不用 ! 运算符)"></a>logicalNeg(x) 计算 !x (不用 ! 运算符)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * logicalNeg - implement the ! operator, using all of </span><br><span class="line"> *              the legal operators except !</span><br><span class="line"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span><br><span class="line"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 12</span><br><span class="line"> *   Rating: 4 </span><br><span class="line"> */</span><br><span class="line">int logicalNeg(int x) &#123;</span><br><span class="line">  return ((x | (~x + 1)) &gt;&gt; 31) + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="howManyBits-x-计算表达-x-所需的最少位数"><a href="#howManyBits-x-计算表达-x-所需的最少位数" class="headerlink" title="howManyBits(x) 计算表达 x 所需的最少位数"></a>howManyBits(x) 计算表达 x 所需的最少位数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two&#x27;s complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">howManyBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="comment">// 原理：对于正数，从高位到低位，找第一个位是1的（比如是n），再加上符号位，则最少需要n+1个位；</span></span><br><span class="line">  <span class="comment">// 对于负数，从高位到低位，找第一个位是0的（比如是n），则最少需要n位</span></span><br><span class="line">  <span class="type">int</span> b16, b8, b4, b2, b1, b0; <span class="comment">// 表示0~15、16~23、24~27、28~29、30、31的位置处是否含有1，如有，则对其赋值需要的位数</span></span><br><span class="line">  <span class="type">int</span> sign = x &gt;&gt; <span class="number">31</span>; <span class="comment">// 取符号位</span></span><br><span class="line">  x = (sign&amp;~x)|(~sign&amp;x); <span class="comment">// 如果x为正则不变，x为负则取反，这里是为了统一正负数，我们之后只用找到含有1的位置即可</span></span><br><span class="line"></span><br><span class="line">  b16 = !!(x &gt;&gt; <span class="number">16</span>) &lt;&lt; <span class="number">4</span>;<span class="comment">// 先看高16位是否含有1，若有则表示至少需要16位，所以给b16赋值为16(1 &lt;&lt; 4 = 16)</span></span><br><span class="line">  x =  x &gt;&gt; b16; <span class="comment">// 若有1，则原数右移16位，因为上面已经确定是否至少需要16位(针对0~15)；若没有1，则b16为0，x不用移位，继续往下面判断</span></span><br><span class="line"></span><br><span class="line">  b8 = !!(x &gt;&gt; <span class="number">8</span>) &lt;&lt; <span class="number">3</span>; <span class="comment">// 看剩余位的高8位是否含有1，若有则表示至少还需要8位，给b8赋值为8</span></span><br><span class="line">  x = x &gt;&gt; b8; <span class="comment">// 同理...</span></span><br><span class="line"></span><br><span class="line">  b4 = !!(x &gt;&gt; <span class="number">4</span>) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">  x = x &gt;&gt; b4;</span><br><span class="line"></span><br><span class="line">  b2 = !!(x &gt;&gt; <span class="number">2</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  x = x &gt;&gt; b2;</span><br><span class="line"></span><br><span class="line">  b1 = !!(x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  x = x &gt;&gt; b1;</span><br><span class="line">  b0 = x;</span><br><span class="line">  <span class="keyword">return</span> b16+b8+b4+b2+b1+b0+<span class="number">1</span>; <span class="comment">// 最后加上符号位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="floatScale2-uf-计算-2-0-uf"><a href="#floatScale2-uf-计算-2-0-uf" class="headerlink" title="floatScale2(uf) 计算 2.0*uf"></a>floatScale2(uf) 计算 2.0*uf</h3><p>需要了解计算机内浮点数的表示方法，了解浮点数中的规格数、非规格数、无穷大和未定义的区别和表示。</p>
<p>我们先看如何表示浮点数：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/2024/07/15/CSAPP%20Lab/float.png" alt="float"></p>
<p>这里的uf类型为unsigned int，并不是浮点数，但是我们将uf看作为单精度类型，它有32位，最高位是符号位，之后8位保存指数信息，最后23位保存小数信息，所以在代码中我们可以看到，我们通过和0x7F800000取与操作来获得指数信息，再右移23位取出这一部分。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/2024/07/15/CSAPP%20Lab/2-32.png" alt="2-32"></p>
<p>浮点数有几种特殊情况：</p>
<p>1.若exp部分全为0(exp = 0)，则是非规格化数，它是一种非常接近0的数；</p>
<p>2.若exp部分全为1(exp = 255)，当小数部分全为0时，表示无穷大；当小数部分不为全0时，表示未初始化数据NaN；</p>
<p>3.以上两种情况以外，就是规格化数。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/2024/07/15/CSAPP%20Lab/2-33.png" alt="2-33"></p>
<p>所以我们需要判断uf是哪一种浮点数，并根据它的类型来进行相应的操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatScale2</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="built_in">exp</span> = (uf&amp;<span class="number">0x7F800000</span>) &gt;&gt; <span class="number">23</span>; <span class="comment">// 取出阶码</span></span><br><span class="line">  <span class="type">int</span> sign = uf&amp;(<span class="number">1</span> &lt;&lt; <span class="number">31</span>); <span class="comment">// 取符号位</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0</span>) <span class="keyword">return</span> uf&lt;&lt;<span class="number">1</span>|sign; <span class="comment">// 若为非规格数，直接给uf乘以2后加上符号位即可</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">255</span>) <span class="keyword">return</span> uf; <span class="comment">// 若为无穷大或者NaN，直接返回自身</span></span><br><span class="line">  <span class="built_in">exp</span> = <span class="built_in">exp</span> + <span class="number">1</span>; <span class="comment">// 若uf乘以2（也就是阶码加1）后变成255，则返回无穷大</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">255</span>) <span class="keyword">return</span> (<span class="number">0x7F800000</span>|sign);</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>)|(uf&amp;<span class="number">0x807FFFFF</span>); <span class="comment">// 返回阶码加1后的原符号数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="floatFloat2Int-uf-计算-int-f"><a href="#floatFloat2Int-uf-计算-int-f" class="headerlink" title="floatFloat2Int(uf) 计算 (int) f"></a>floatFloat2Int(uf) 计算 (int) f</h3><p>需要了解整数和浮点数之间的转化方法，我们要做的就是将浮点数中的指数部分和小数部分取出来，然后通过这两部分来转化为整数，具体操作可以看代码，在这个过程中还要判断是否会产生溢出，以及浮点数是否为规格数等情况，如果产生溢出，我们需要返回一个特定的溢出值。</p>
<p>这里有一个将整数转化为浮点数的例子：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/2024/07/15/CSAPP%20Lab/prac.png" alt="prac"></p>
<h3 id="floatPower2-x-计算-2-0的x次方"><a href="#floatPower2-x-计算-2-0的x次方" class="headerlink" title="floatPower2(x) 计算 2.0的x次方"></a>floatPower2(x) 计算 2.0的x次方</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class="line"><span class="comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class="line"><span class="comment"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class="line"><span class="comment"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class="line"><span class="comment"> *   0. If too large, return +INF.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while </span></span><br><span class="line"><span class="comment"> *   Max ops: 30 </span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatPower2</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> INF = <span class="number">0xFF</span> &lt;&lt; <span class="number">23</span>; <span class="comment">// 设定一个最大值，也就是阶码位置都为1</span></span><br><span class="line">  <span class="type">int</span> <span class="built_in">exp</span> = x + <span class="number">127</span>; <span class="comment">// 计算阶码</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 阶码小于等于0，则返回0</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> &gt;= <span class="number">255</span>) <span class="keyword">return</span> INF; <span class="comment">// 阶码大于等于255，则返回INF</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<div class="article-footer reveal fs14"><section id="license"><div class="header"><span>License</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div></section></div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="header cap theme"><span>READ NEXT</span></section><section class="body fs14"><a id="next" href="/2024/07/15/CSAPP/">CSAPP<span class="note">Older</span></a><div class="line"></div><a id="prev" href="/2024/07/15/6.824_T1-MapReduceRPC/">6.824 W1 MapReduce, RPC & threads<span class="note">Newer</span></a></section></div>








      
<footer class="page-footer reveal fs12"><hr><div class="text"><p>All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</p>
<p>This site was deployed by <a href="http://example.com/">@zennlyu</a> using <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.8.0" title="v1.8.0">Stellar</a>.</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.8.0';
  stellar.config = {
    date_suffix: {
      just: 'Just',
      min: 'minutes ago',
      hour: 'hours ago',
      day: 'days ago',
      month: 'months ago',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://fastly.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js',
    sitesjs: '/js/plugins/sites.js',
    friendsjs: '/js/plugins/friends.js',
  };

  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://fastly.jsdelivr.net/npm/vanilla-lazyload@17.3.1/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@6/swiper-bundle.min.css","js":"https://unpkg.com/swiper@6/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://fastly.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://fastly.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://fastly.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://fastly.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://fastly.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti/umd/heti.min.css","js":"https://unpkg.com/heti/umd/heti-addon.min.js"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->



<!-- inject -->


  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
