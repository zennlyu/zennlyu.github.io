---
title: CSAPP-03 Machine Level Programming
categories: [csapp]
tags: [csapp]
---

## 1 历史观点

## 2 程序编码

```shell
linux> gcc -Og -o p p1.c p2.c
```

实际上 gcc 命令调用了一整套的程序，将源代码转化成可执行代码。

- 首先，C 预处理器扩展源代码，插入所有用#include 命令指定的文件，并扩展所有用#define 声明指定的宏。
- 其次，编译器产生两个源文件的汇编代码，名字分别为 P1. S 和 p2. S。
- 接下来，汇编器会将汇编代码转化成二进制目标代码文件 p1.o 和 p2.o。目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入全局值的地址。
- 最后，链接器将两个目标代码文件与实现库函数（例如 printf）的代码合并，并产生最终的可执行代码文件 p（由命令行指示符 -o p 指定的）。可执行代码是我们要考虑的机器代码的第二种形式，也就是处理器执行的代码格式。

### 机器级代码

对于机器级编程来说，2 种抽象尤为重要

- 由指今集体系结构或指令集架构（Instruction Set Architecture, ISA） 来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。
- 第二种抽象是，机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来。

x86-64 的机器代码和原始的 C 代码差别非常大。一些通常对 C 语言程序员隐藏的处理器状态都是可见的：

- ● 程序计数器（通常称为“PC”，在 x86-64 中用号 rip 表示）给出将要执行的下一条指令在内存中的地址。
- ● 整数寄存器文件包含 16 个命名的位置，分别存储 64 位的值。这些寄存器可以存储地址（对应于 C 语言的指针）或整数数据，有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。
- ● 条件码寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化，比如说用来实现 if 和 while 语句。）
- ● 一组向量寄存器可以存放一个或多个整数或浮点数值。

机器代码只是简单地将内存看成一个很大的、按字节寻址的数组。

程序内存包含：程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的内存块（比如说用 ma11oc 库函数分配的）。

程序内存用虚拟地址来寻址。在任意给定的时刻，只有有限的一部分虚拟地址被认为是合法的。

> 例如，x86-64 的虚拟地址是由 64 位的字来表示的。在目前的实现中，这些地址的高 16 位必须设置为 0，所以一个地址实际上能够指定的是 248 或 64TB 范围内的一个字节。较为典型的程序只会访问几兆字节或几千兆字节的数据。操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址。

### 代码示例

### 关于格式的注解

#### ATT 与 Intel 汇编代码格式

#### 内联汇编

## 3 数据格式

由于是从 16 位体系结构扩展成 32 位的，Intel 用术语 “字（word）”表示 16 位数据类型。因此，称 32 位数为“双字（double words）”，称 64 位数为“四字（quad words）”。

图 3-1 给出了 C 语言基本数据类型对应的 x86-64 表示。标准 int 值存储为双字（32 位）。指针（在此用 char*表示）存储为 8 字节的四字，64 位机器本来就预期如此。x86-64 中，数据类型 1ong 实现为 64 位，允许表示的值范围较大。本章代码示例中的大部分都使用了指针和 1ong 数据类型，所以都是四字操作。x86-64 指令集同样包括完整的针对字节、字和双字的指令。![3-1](3-1.png)

浮点数主要有两种形式：

- 单精度（4 字节）值，对应于 C 语言数据类型 f1oat；
- 双精度（8 字节）值，对应于 C 语言数据类型 double。

x86 家族的微处理器历史上实现过对一种特殊的 80 位（10 字节）浮点格式进行全套的浮点运算（参见家庭作业 2.86）。可以在 C 程序中用声明 long double 来指定这种格式。不过我们不建议使用这种格式。它不能移植到其他类型的机器上，而且实现的硬件也不如单精度和双精度算术运算的高效。

如图所示，大多数 GCC 生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。

> 例如，数据传送指令有四个变种：movb（传送字节）、movw（传送字）、movl（传送双字）和 movg（传送四字）。后缀‘l’用来表示双字，因为 32 位数被看成是“长字（long word）”。

注意，汇编代码也使用后缀 'l'来表示 4 字节整数和 8 字节双精度浮点数。这不会产生歧义，因为浮点数使用的是一组完全不同的指令和寄存器。

## 4 访问信息

一个 x86-64 的中央处理单元（CPU）包含一组 16 个存储 64 位值的通用目的寄存器。这些寄存器用来存储整数数据和指针。![3-2](/Users/mac/github/zennlyu.github.io/hexo/source/statics/csapp/3-2.png)

图 3-2 显示了这 16 个寄存器。它们的名字都以号 r 开头，不过后面还跟着一些不同的命名规则的名字，这是由于指令集历史演化造成的。

最初的 8086 中有 8 个 16 位的寄存器，即图 3-2 中的 %ax 到 %bp。每个寄存器都有特殊的用途，它们的名字就反映了这些不同的用途。扩展到 IA32 架构时，这些寄存器也扩展成 32 位寄存器，标号从 %eax 到 %ebp。扩展到 x86-64 后，原来的 8 个寄存器扩展成 64 位，标号从 %rax 到 %rbp。除此之外，还增加了 8 个新的寄存器，它们的标号是按照新的命名规则制定的：从 %r8 到 %r15。

如图 3-2 中嵌套的方框标明的，指令可以对这 16 个寄存器的低位字节中存放的不同大小的数据进行操作。字节级操作可以访问最低的字节，16 位操作可以访问最低的 2 个字节，32 位操作可以访问最低的 4 个字节，而 64 位操作可以访问整个寄存器。

在后面的章节中，我们会展现很多指令，复制和生成 1 字节、2 字节、4 字节和 8 字节值。当这些指令以寄存器作为目标时，对于生成小于 8 字节结果的指令，寄存器中剩下的字节会怎么样，对此有两条规则：生成 1 字节和 2 字节数字的指令会保持剩下的字节不变；生成 4 字节数字的指令会把高位 4 个字节置为 0。后面这条规则是作为从 IA32 到 x86-64 的扩展的一部分而采用的。

就像图 3-2 右边的解释说明的那样，在常见的程序里不同的寄存器扮演不同的角色。

其中最特别的是栈指针 %rsp，用来指明运行时栈的结束位置。有些程序会明确地读写这个寄存器。另外 15 个寄存器的用法更灵活。少量指令会使用某些特定的寄存器。更重要的是，有一组标准的编程规范控制着如何使用寄存器来管理栈、传递函数参数、从函数的返回值，以及存储局部和临时数据。我们会在描述过程的实现时（特别是在 3.7 节中），讲述这些惯例。

### 操作数指示符

大多数指令有一个或多个操作数（operand）指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。x86-64 支持多种操作数格式（参见图 3-3）。源数据值可以以常数形式给出，或是从寄存器或内存中读出。结果可以存放在寄存器或内存中。因此，各种不同的操作数的可能性被分为三种类型。第一种类型是立即数（immediate）用来表示常数值。在 ATT 格式的汇编代码中，立即数的书写方式是‘$’后面跟一个用标准 C 表示法表示的整数，比如，$-577 或$0x1F。不同的指令允许的立即数值范围不同，汇编器会自动选择最紧凑的方式进行数值编码。第二种类型是寄存器（register）它表示某个寄存器的内容，16 个寄存器的低位 1 字节、2 字节、4 字节或 8 字节中的一个作为操作数，这些字节数分别对应于 8 位、16 位、32 位或 64 位。在图 3-3 中，我们用符号 ra 来表示任意寄存器 a，用引用 R [ra】来表示它的值，这是将寄存器集合看成一个数组 R，用寄存器标识符作为索引。

第三类操作数是内存引用，它会根据计算出来的地址（通常称为有效地址）访问某个内存位置。因为将内存看成一个很大的字节数组，我们用符号 M [Addr】表示对存储在内存中从地址 Addr 开始的 b 个字节值的引用。为了简便，我们通常省去下标 b。

如图 3-3 所示，有多种不同的寻址模式允许不同形式的内存引用。表中底部用语法 $Imm(r_b, r_i, s)$ 表示的是最常用的形式。这样的引用有四个组成部分：一个立即数偏移 $Imm$，一个基址寄存器 $r_b$，一个变址寄存器 $r_i$；和一个比例因子 $s$，这里 s 必须是 1、2、4 或者 8。基址和变址寄存器都必须是 64 位寄存器。有效地址被计算为 $Imm+R[r_b]+R[r_i]·s$。引用数组元素时，会用到这种通用形式。其他形式都是这种通用形式的特殊情况，只是省略了某些部分。正如我们将看到的，当引用数组和结构元素时，比较复杂的寻址模式是很有用的。

![3-3](3-3.png)



### 数据传送指令

最频繁使用的指令是将数据从一个位置复制到另一个位置的指令。操作数表示的通用性使得一条简单的数据传送指令能够完成在许多机器中要好几条不同指令才能完成的功能。我们会介绍多种不同的数据传送指令，它们或者源和目的类型不同，或者执行的转换不同，或者具有的一些副作用不同。在我们的讲述中，把许多不同的指令划分成指令类每一类中的指令执行相同的操作，只不过操作数大小不同。

图 3-4 列出的是最简单形式的数据传送指令—— `mov` 类。这些指令把数据从源位置复制到目的位置，不做任何变化。`mov` 类由四条指令组成：`movb`、`movw`、`movl` 和 `movq`。这些指令都执行同样的操作；主要区别在于它们操作的数据大小不同：分别是 1、2、4 和 8 字节。

![3-4](/Users/kedae/Desktop/zennlyu.github.io/hexo/source/_posts/15-213-Ch03 Machine Level/3-4.png)

源操作数指定的值是一个立即数，存储在寄存器中或者内存中。目的操作数指定一个位置，要么是一个寄存器或者，要么是一个内存地址。x86-64 加了一条限制，传送指令的两个操作数不能都指向内存位置。将一个值从一个内存位置复制到另一个内存位置需要两条指令—第一条指令将源值加载到寄存器中，第二条将该寄存器值写入目的位置。参考图 3-2，这些指令的寄存器操作数可以是 16 个寄存器有标号部分中的任意一个，寄存器部分的大小必须与指令最后一个字符（‘b’, ‘w’, ‘1'或‘q’）指定的大小匹配。大多数情况中，MV 指令只会更新目的操作数指定的那些寄存器字节或内存位置。唯一的例外是 movl 指令以寄存器作为目的时，它会把该寄存器的高位 4 字节设置为 0。造成这个例外的原因是 x86-64 采用的惯例，即任何为寄存器生成 32 位值的指令都会把该寄存器的高位部分置成 0。

下面的 mov 指令示例给出了源和目的类型的五种可能的组合。记住，第一个是源操作数，第二个是目的操作数：

```assembly
movl $0x4050,%eax
movw %bp,%sp
movb (%rdi,%rcx),%al
movb $-17,(%rsp)
movq %rax,-12(%rbp)
```

图 3-4 中记录的最后一条指令是处理 64 位立即数数据的。常规的 movq 指令只能以表示为 32 位补码数字的立即数作为源操作数，然后把这个值符号扩展得到 64 位的值，放到目的位置。`movabsq` 指令能够以任意 64 位立即数值作为源操作数，并且只能以寄存器作为目的。

图 3-5 和图 3-6 记录的是两类数据移动指令，在将较小的源值复制到较大的目的时使用。所有这些指令都把数据从源（在寄存器或内存中）复制到目的寄存器。MOVZ 类中的指令把目的中剩余的字节填充为 0，而 MOVS 类中的指令通过符号扩展来填充，把源操作的最高位进行复制。可以观察到，每条指令名字的最后两个字符都是大小指示符：第一个字符指定源的大小，而第二个指明目的的大小。正如看到的那样，这两个类中每个都有三条指令，包括了所有的源大小为 1 个和 2 个字节、目的大小为 2 个和 4 个的情况，当然只考虑目的大于源的情况。

![3-5-6](/Users/kedae/Desktop/zennlyu.github.io/hexo/source/_posts/15-213-Ch03 Machine Level/3-5-6.png)

注意图 3-5 中并没有一条明确的指令把 4 字节源值零扩展到 8 字节目的。这样的指令逻辑上应该被命名为 movz1q，但是并没有这样的指令。不过，这样的数据传送可以用以寄存器为目的的 mov1 指令来实现。这一技术利用的属性是，生成 4 字节值并以寄存器作为目的的指令会把高 4 字节置为 0。对于 64 位的目标，所有三种源类型都有对应的符号扩展传送，而只有两种较小的源类型有零扩展传送。

图 3-6 还给出 cltq 指令。这条指令没有操作数：它总是以寄存器 %eax 作为源，%rax 作为符号扩展结果的目的。它的效果与指令 movslq, %eax,% rax 完全一致，不过编码更紧凑。

#### 旁注: 理解数据传送如何改变目的寄存器

正如我们描述的那样，关于数据传送指令是否以及如何修改目的寄存器的高位字节有两种不同的方法。下面这段代码序列会说明其差别：

```assembly
movabsq $0x0011223344556677, %rax 
// %rax=0011223344556677
movb $-1, %al %raX=00112233445566FF
movw $-1, %ax %rax=001122334455FFFF
movl $-1, %eax %rax =00000000FFFFFFFF
movq $-1, %rax %rax =FFFFFFFFFFFFFFFF
```

在接下来的讨论中，我们使用十六进制表示。在这个例子中，第 1 行的指令把寄存器 %rax 初始化为位模式 0011223344556677。剩下的指令的源操作数值是立即数值一 1。回想一 1 的十六进制表示形如 FF…F，这里 F 的数量是表述中字节数量的两倍。因此 movb 指令（第 2 行）把 rax 的低位字节设置为 FF，而 movw 指令（第 3 行）把低 2 位字节设置为 FFFF，剩下的字节保持不变。movl 指令（第 4 行）将低 4 个字节设置为 FFFFFFFF，同时把高位 4 字节设置为 00000000。最后 movq 指令（第 5 行）把整个寄存器设置为 FFFFFFFFFFFFFFFF。

#### 旁注: 字节传送指令比较

下面这个示例说明了不同的数据传送指令如何改变或者不改变目的的高位字节。仔细观察可以发现，三个字节传送指令 movb、movsbq 和 movzbq 之间有细微的差别。示例如下：

```assembly
movabsq $0x0011223344556677, %rax 
//%rax=0011223344556677
movb $0xAA, %dl 	// %dl =AA
movb %d1, %al 		// %rax=00112233445566AA
movsbq %d1, %rax 	// %rax=FFFFFFFFFFFFFFAA
movzbq %dl, %rax 	// %rax=00000000000000AA
```

在下面的讨论中，所有的值都使用十六进制表示。代码的头 2 行将寄存器 %rax 和 %dl 分别初始化为 0011223344556677 和 AA。剩下的指令都是将 %rdx 的低位字节复制到 %rax 的低位字节。movb 指令（第 3 行）不改变其他字节。根据源字节的最高位，movsbq 指令（第 4 行）将其他 7 个字节设为全 1 或全 0。由于十六进制 A 表示二进制值 1010，符号扩展会把高位字节都设置为 FE。movzbq 指令（第 5 行）总是将其他 7 个字节全都设置为 0。



### 数据传送示例

作为一个使用数据传送指令的代码示例，考虑图 3-7 中所示的数据交换函数，既有 C 代码，也有 GCC 产生的汇编代码。

```c
long exchange(long *xp, long y) {
  long x = *xp;
  *xp = y;
  return x;
}
```

```assembly
(xp in %rdi, y in %rsi)
exchange:
	movq	(%rdi), %rax		Get x at xp. Set as return value
	movq	%rsi, (%rdi)		Store y at xp.
	ret										Return.
```

如图 3-7b 所示，函数 exchange 由三条指令实现：两个数据传送（movq），加上一条返回函数被调用点的指令（ret）。我们会在 3.7 节中讲述函数调用和返回的细节。在此之前，知道参数通过寄存器传递给函数就足够了。我们对汇编代码添加注释来加以说明。函数通过把值存储在寄存器号 rax 或该寄存器的某个低位部分中返回。

当过程开始执行时，过程参数 xp 和 y 分别存储在寄存器号 rdi 和号 rsi 中。然后，指令 2 从内存中读出 x，把它存放到寄存器号 rax 中，直接实现了 C 程序中的操作 x=*xP。稍后，用寄存器号 ra×从这个函数返回一个值，因而返回值就是 x。指令 3 将 y 写人到寄存器号 rdi 中的 p 指向的内存位置，直接实现了操作*xp=y。这个例子说明了如何用 MOV 指令从内存中读值到寄存器（第 2 行），如何从寄存器写到内存（第 3 行）。

关于这段汇编代码有两点值得注意。首先我们看到 C 语言中所谓的“指针”其实就是地址。间接引用指针就是将该指针放在一个寄存器中，然后在内存引用中使用这个寄存器。其次，像×这样的局部变量通常是保存在寄存器中，而不是内存中。访问寄存器比访问内存要快得多。



### 压入和弹出栈数据

最后两个数据传送操作可以将数据压入程序栈中，以及从程序栈中弹出数据，如图 3-8 所示。正如我们将看到的，栈在处理过程调用中起到至关重要的作用。栈是一种数据结构，可以添加或者删除值，不过要遵循“后进先出”的原则。通过 push 操作把数据压入栈中，通过 pop 操作删除数据；它具有一个属性：弹出的值永远是最近被压入而且仍然在栈中的值。栈可以实现为一个数组，总是从数组的一端插入和删除元素。这一端被称为栈顶。在 x86-64 中，程序栈存放在内存中某个区域。如图 3-9 所示，栈向下增长，这样一来，栈顶元素的地址是所有栈中元素地址中最低的。（根据惯例，我们的栈是倒过来画的，栈“顶”在图的底部。）栈指针 %rsp 保存着栈顶元素的地址。

![3-8](/Users/kedae/Desktop/zennlyu.github.io/hexo/source/_posts/15-213-Ch03 Machine Level/3-8.png)

pushq 指令的功能是把数据压入到栈上，而 popq 指令是弹出数据。这些指令都只有一个操作数一一压入的数据源和弹出的数据目的。

将一个四字值压入栈中，首先要将栈指针减 8，然后将值写到新的栈顶地址。因此，指令 pushq %rbp 的行为等价于下面两条指令：

```assembly
subq $8, %rsp			Decrement stack pointer
movq %rbp,(%rsp)	Store %rbp on stack
```

它们之间的区别是在机器代码中 pushq 指令编码为 1 个字节，而上面那两条指令一共需要 8 个字节。图 3-9 中前两栏给出的是，当 %rsp 为 0x108, rax 为 0x123 时，执行指令 pushq %rax 的效果。首先 %rsp 会减 8，得到 0x100, 然后会将 0x123 存放到内存地址 0x100 处。

![3-9](/Users/kedae/Desktop/zennlyu.github.io/hexo/source/_posts/15-213-Ch03 Machine Level/3-9.png)

弹出一个四字的操作包括从栈顶位置读出数据，然后将栈指针加 8。因此，指令 popq grax 等价于下面两条指令：

```assembly
movq (%rsp), %rax //Read %rax from stack
addq $8, %rsp //Increment stack pointer
```

图 3-9 的第三栏说明的是在执行完 pushq 后立即执行指令 popq &rdx 的效果。先从内存中读出值 0x123, 再写到寄存器 rdx 中，然后，寄存器 rsp 的值将增加回到 0x108。如图中所示，值 0x123 仍然会保持在内存位置 0x100 中，直到被覆盖（例如被另一条入栈操作覆盖）。无论如何，%rsp 指向的地址总是栈顶。

因为栈和程序代码以及其他形式的程序数据都是放在同一内存中，所以程序可以用标准的内存寻址方法访问栈内的任意位置。例如，假设栈顶元素是四字，指令 movq8 (rsp), rdx 会将第二个四字从栈中复制到寄存器 rdx。

## 5 算数和逻辑操作

图 3-10 列出了 x86-64 的一些整数和逻辑操作。大多数操作都分成了指令类，这些指令类有各种带不同大小操作数的变种（只有 1eaq 没有其他大小的变种）。例如，指令类 ADD 由四条加法指令组成：addb、addw、addl 和 addq，分别是字节加法、字加法、双学加法和四字加法。事实上，给出的每个指令类都有对这四种不同大小数据的指令。这些操作被分为四组：加载有效地址、一元操作、二元操作和移位。二元操作有两个操作数，而一元操作有一个操作数。这些操作数的描述方法与 3.4 节中所讲的一样。

![3-10](/Users/kedae/Desktop/zennlyu.github.io/hexo/source/_posts/15-213-Ch03 Machine Level/3-10.png)

### 加载有效地址

加载有效地址（load effective address）指令 leaq 实际上是 movq 指令的变形。它的指令形式是从内存读数据到寄存器，但实际上它根本就没有引用内存。它的第一个操作数看上去是一个内存引用，但该指令并不是从指定的位置读入数据，而是将有效地址写入到目的操作数。

在图 3-10 中我们用 C 语言的地址操作符&S 说明这种计算。这条指令可以为后面的内存引用产生指针。另外，它还可以简洁地描述普通的算术操作。

例如，如果寄存器 rdx 的值为 x，那么指令 `leaq 7 (%rdx,%rdx,4), %rax` 将设置寄存器 `%rax` 的值为 `5x+7`。编译器经常发现 `leaq` 的一些灵活用法，根本就与有效地址计算无关。目的操作数必须是一个寄存器。

为了说明 leap 在编译出的代码中的使用，看看下面这个 C 程序：

```c
long scale(long x, long y, long z) {
	long t = x+4*y+12*z;
	return t;
}
```

编译时，该函数的算术运算以三条 leaq 指令实现，就像右边注释说明的那样：

```assembly
long scale (long x, long y, long z) 
x in Ardi, y in Xrsi, z in Xrdx 
scale: 
	leaq  (%rdi, %rsi, 4), %rax 		x+4*y 
	leaq  (%rdx, %rdx, 2), %rdx 		z+2*z=3*z 
	leaq  (%rax, %rdx, 4), %rax  		(x+4*y)+4*(3*z)=x+4y+12+z
	ret
```

leaq 指令能执行加法和有限形式的乘法，在编译如上简单的算术表达式时，是很有用处的。

### 一元和二元操作

第二组中的操作是一元操作，只有一个操作数，既是源又是目的。这个操作数可以是一个寄存器，也可以是一个内存位置。比如说，指令 incq (rsp）会使栈顶的 8 字节元素加 1。这种语法让人想起 C 语言中的加 1 运算符（++）和减 1 运算符（一一）。

第三组是二元操作，其中，第二个操作数既是源又是目的。这种语法让人想起语言中的赋值运算符，例如 x-=y。不过，要注意，源操作数是第一个，目的操作数是第二个，对于不可交换操作来说，这看上去很奇特。例如，指令 subq %rax, %rdx 使寄存器 %rdx 的值减去 %rax 中的值。（将指令解读成“从 %rdx 中减去 %rax”会有所帮助。）第一个操作数可以是立即数、寄存器或是内存位置。第二个操作数可以是寄存器或是内存位置。注意，当第二个操作数为内存地址时，处理器必须从内存读出值，执行操作，再把结果写回内存。

### 移位操作

最后一组是移位操作，先给出移位量，然后第二项给出的是要移位的数。可以进行算术和逻辑右移。移位量可以是一个立即数，或者放在单字节寄存器 1 中。（这些指令很特别，因为只允许以这个特定的寄存器作为操作数。）原则上来说，1 个字节的移位量使得移位量的编码范围可以达到 2 一 1=255。x86-64 中，移位操作对 w 位长的数据值进行操作，移位量是由 c1 寄存器的低 m 位决定的，这里 2=w。高位会被忽略。所以，例如当寄存器 8c1 的十六进制值为 0xFF 时，指令 salb 会移 7 位，sa1w 会移 15 位，sa11 会移 31 位，而 sa1q 会移 63 位。

如图 3-10 所示，左移指令有两个名字：SAL 和 SHL。两者的效果是一样的，都是将右边填上 0。右移指令不同，SAR 执行算术移位（填上符号位），而 SHR 执行逻辑移位（填上 0)。移位操作的目的操作数可以是一个寄存器或是一个内存位置。图 3-10 中用>>_A（算术）和 >>_L（遷辑）来表示这两种不同的右移运算。

### 讨论

我们看到图 3-10 所示的大多数指令，既可以用于无符号运算，也可以用于补码运算。只有右移操作要求区分有符号和无符号数。这个特性使得补码运算成为实现有符号整数运算的一种比较好的方法的原因之一。

图 3-11 给出了一个执行算术操作的函数示例，以及它的汇编代码。参数 x、y 和 z 初始时分别存放在内存 rdi、rsi 和 rdx 中。汇编代码指令和 C 源代码行对应很紧密。第 2 行计算 x^y 的值。指令 3 和 4 用 1eaq 和移位指令的组合来实现表达式 z*48。第 5 行计算 t1 和 0x0F0F0F0F 的 AND 值。第 6 行计算最后的减法。由于减法的目的寄存器是 rax，函数会返回这个值。

![3-11](/Users/kedae/Desktop/zennlyu.github.io/hexo/source/_posts/15-213-Ch03 Machine Level/3-11.png)

在图 3-11 的汇编代码中，寄存器 rax 中的值先后对应于程序值 3*z、z*48 和 t4（作为返回值）。通常，编译器产生的代码中，会用一个寄存器存放多个程序值，还会在寄存器之间传送程序值。

### 特殊的算术控制

正如我们在 2.3 节中看到的，两个 64 位有符号或无符号整数相乘得到的乘积需要 128 位来表示。x86-64 指令集对 128 位（16 字节）数的操作提供有限的支持。延续字（2 字节）、双字（4 字节）和四字（8 字节）的命名惯例，Intel 把 16 字节的数称为八字（oct word）。图 3-12 描述的是支持产生两个 64 位数字的全 128 位乘积以及整数除法的指令。

imulq 指令有两种不同的形式。其中一种，如图 3-10 所示，是 IMUL 指令类中的一种。这种形式的 imulq 指令是一个“双操作数”乘法指令。它从两个 64 位操作数产生一个 64 位乘积，实现了 2.3.4 和 2.3.5 节中描述的操作和。（回想一下，当将乘积截取到 64 位时，无符号乘和补码乘的位级行为是一样的。）

此外，x86-64 指令集还提供了两条不同的“单操作数”乘法指令，以计算两个 64 位值的全 128 位乘积一一个是无符号数乘法（mulq），而另一个是补码乘法（imulq）。这两条指令都要求一个参数必须在寄存器号 xax 中，而另一个作为指令的源操作数给出。然后乘积存放在寄存器 rdx（高 64 位）和 rax（低 64 位）中。虽然 imulq 这个名字可以用于两个不同的乘法操作，但是汇编器能够通过计算操作数的数目，分辨出想用哪条指令。

下面这段 C 代码是一个示例，说明了如何从两个无符号 64 位数字 x 和 y 生成 128 位的乘积：

```c
#include <inttypes.h>
typedef unsigned __int128 uint128_t;

void store_uprod(uint128_t *dest, uint64_t x, uint64_t y) {
	*dest = x*(uint128_t) y;
}
```

在这个程序中，我们显式地把 x 和 y 声明为 64 位的数字，使用文件 inttypes.h 中声明的定义，这是对标准 C 扩展的一部分。不幸的是，这个标准没有提供 128 位的值。所以我们只好依赖 GCC 提供的 128 位整数支持，用名字 int128 来声明。代码用 typedef 声明定义了一个数据类型 uint128t，沿用的 inttypes. H 中其他数据类型的命名规律。这段代码指明得到的乘积应该存放在指针 dest 指向的 16 字节处。

GCC 生成的汇编代码如下：

## 6 控制

### 条件码

### 访问条件码

### 跳转指令

### 跳转指令的编码

### 用条件控制来实现条件分支

### 用条件传送来实现条件分支

### 循环

### do-while

### while

### for

### switch

## 7 过程

### 运行时栈

### 转移控制

### 数据传送

### 栈上的局部存储

### 寄存器中的局部存储空间

### 递归过程

## 8 数组分配和访问

### 基本原则

### 指针运算

### 嵌套的数组

### 定长数组

### 变长数组



## 9 异质的数据结构

### 结构

### 联合

### 数据对齐

## 10 在机器级程序中将控制与数据结合起来

### 理解指针

### 应用：使用 GDB 调试器

### 内存越界引用和缓冲区溢出

### 对抗缓冲区溢出攻击

#### 栈随机化

#### 栈破坏检测

#### 限制可执行代码区域

#### 支持变长栈帧

## 11 浮点代码

### 浮点传送和转换操作

### 过程中的浮点代码

### 浮点运算操作

### 定义和使用浮点常数

### 在浮点代码中使用位级操作

### 浮点比较操作

### 对浮点代码的观察结论
