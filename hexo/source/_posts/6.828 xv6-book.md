---
title: S081 xv6-book
categories: [operating system]
tags: [S081]
---

## Chapter 1 Operating System Interfaces

### 1.1 Processes and Memory

An xv6 process consists of

- 用户空间内存(指令、数据和堆栈)
- 内核私有的进程状态

Xv6 *time-shares* processes:

- 进程共享 cpu，它透明地切换当前 cpu 正在执行的进程。
- 当一个进程暂时不使用 cpu 时， xv6 会保存它的 CPU 寄存器，在下次运行该进程时恢复它们。
- 内核为每个进程关联一个 PID (进程标识符)。

#### `fork`

Fork returns in both the parent and the child

- 父进程中，`fork`  返回子进程的 PID;

- 在子进程中，` fork`  返回 0

#### `exit`

退出调用进程，并释放资源，如内存和打开的文件。`exit` 需要一个整数状 态参数，通常 0 表示成功，1 表示失败。

#### `wait`

返回当前进程的一个已退出(或被杀死)的子进程的 PID，并将该子进程的退出状态码复制到一个地址，该地址由 wait 参数提供;

如果调用者的子进程都没有退出，则  `wait`  等待一个子进程退出。如果调用者没有子进程，wait 立即返回-1。

如果父进程不关心子进程的退出状态，可以传递一个 0 地址给 wait。

```c
int pid = fork();
if (pid > 0){
	printf("parent: child=%d\n", pid);
	pid = wait((int *) 0);
	printf("child %d is done\n", pid); 
} else if(pid == 0){
	printf("child: exiting\n");
	exit(0);
} else {
	printf("fork error\n");
}
//  parent: child=3884 
//	child: exiting 
//	child 3884 is done
//	可能会以任何一种顺序输出，这取决于是父进程还是子进程先执行它的 printf 调用。在子程序退出后，父进程的 wait 返回，父进程执行 printf。
//	虽然子进程最初与父进程拥有相同的内存内容，但父进程和子进程是在不同的内存和不 同的寄存器中执行的:改变其中一个进程中的变量不会影响另一个进程。例如，当 wait 的 返回值存储到父进程的 pid 变量中时，并不会改变子进程中的变量 pid。子进程中的 pid 值仍然为零。
```

#### `exec`

使用新内存映像来替换进程的内存， 新内存映像从文件系统中的文件中 进行读取。

这个文件必须有特定的格式，它指定了文件中哪部分存放指令，哪部分是数据， 在哪条指令开始等等

> xv6 uses the ELF format

当 ` exec` 成功时，它并不返回到调用程序;相反，从文件中加载的指令在 ELF 头声明的入口点开始执行。

` exec` 需要两个参数:

- 包含可执行文件的文件名
- 一个字符串参数数组

例如：

```c
char *argv[3];
argv[0] = "echo";
argv[1] = "hello"; 
argv[2] = 0; 
exec("/bin/echo", argv); 
printf("exec error\n");
//	上述代码会执行 /bin/echo 程序，并将 argv 数组作为参数。大多数程序都会忽略参数数 组的第一个元素，也就是程序名称。
```

#### Shell

xv6 shell 使用上述调用来在用户空间运行程序。shell 的主结构很简单，参见 `main(user/sh.c:145)`。

> 主循环用 `getcmd` 读取用户的一行输入，然后调用 `fork` ，创建 shell 副 本。父进程调用 wait，而子进程则运行命令。例如，如果用户向 shell 输入了  `echo hello` ， 那么就会调用 `runcmd`，参数为  `echo hello` 。`runcmd` (user/sh.c:58) 运行实际的命令。对于  `echo hello` ，它会调用 ` exec` (user/sh.c:78)。如果 ` exec` 成功，那么子进程将执行 echo 程序的 指令，而不是 `runcmd` 的。在某些时候，`echo` 会调用 ` exit`，这将使父程序从 main(user/sh.c:145) 中的  `wait`  返回。 (user/sh.c:145). 

你可能会奇怪为什么 `fork`  和 ` exec` 没有结合在一次调用中，我们后面会看到 shell 在实 现 I/O 重定向时利用了这种分离的特性。为了避免创建相同进程并立即替换它(使用 exec) 所带来的浪费，内核通过使用虚拟内存技术 (如 copy-on-write) 来优化这种用例的 fork 实现(见 4.6 节)。

xv6 隐式分配大部分用户空间内存: `fork`  复制父进程的内存到子进程，` exec` 分配足够 的内存来容纳可执行文件。一个进程如果在运行时需要更多的内存(可能是为了 `malloc`)， 可以调用 sbrk(n)将其数据内存增长 n 个字节; sbrk 返回新内存的位置。



### 1.2 I/O and File Descriptor

文件描述符是一个小整数，代表一个可由进程读取或写入的内核管理对象。

一个进程可以通过打开一个文件、目录、设备，或者通过创建一个管道，或者通过复制一个现有的描述符来获得一个文件描述符。

为了简单起见，我们通常将文件描述符所指向的对象称为文件; 文件描述符接口将文件、管道和设备之间的差异抽象化，使它们看起来都像字节流。我们把输入和输出称为 I/O。

在内部，xv6 内核为每一个进程单独维护一个以文件描述符为索引的表，因此每个进程 都有一个从 0 开始的文件描述符私有空间。按照约定，一个进程从文件描述符 0(标准输入) 读取数据，向文件描述符 1(标准输出)写入输出，向文件描述符 2(标准错误)写入错误信息。 正如我们将看到的那样，shell 利用这个约定来实现 I/O 重定向和管道。shell 确保自己总是 有三个文件描述符打开(user/sh.c:151)，这些文件描述符默认是控制台的文件描述符。

#### `read/write` 

`read/write`  系统调用可以从文件描述符指向的文件读写数据。

- `read(fd, buf, n)` 

  > 从文件描述符 `fd` 中读取不超过 `n` 个字节的数据，将它们复制到 `buf` 中，并返回读取的字节数。
  >
  > 每个引用文件的文件描述符都有一个与之相关的偏移量。读取从当前文件偏移量中读取数 据，然后按读取的字节数推进偏移量，随后的读取将返回上次读取之后的数据。当没有更多 的字节可读时，读返回零，表示文件的结束。

- `write(fd, buf, n)` 

  > 表示将 `buf` 中的 `n` 个字节写入文件描述符 `fd` 中，并返回写入的字节数。若写入字节数小于 n 则该次写入发生错误。
  >
  > 和 `read` 一样，`write` 在当前文件偏移量处写入 数据，然后按写入的字节数将偏移量向前推进: 每次写入都从上一次写入的地方开始。

下面的程序片段 (程序 `cat` 的核心代码)将数据从其标准输入复制到其标准输出。如果出现错误，它会向标准错误写入一条消息。

```c
char bug[512];
int n;

for (;;) {
	n = read(0, buf, sizeof buf);
	if (n == 0)
	{
		break;
	}
	if (n < 0)
	{
		fprintf(2, "read error\n");
		exit(1);
	}
	if (write(1, buf, n) != n) 
	{
		fprintf(2, "write error\n");
		exit(1);
	}
}
// 需要注意的是，cat 不知道它是从文件、控制台还是管道中读取的。 同样，cat 也不知道它是在打印到控制台、文件还是其他什么地方。文件描述符的使用和 0 代表输入，1 代表输出的约定，使得 cat 可以很容易实现。
```

#### `close`

`close` 系统调用会释放一个文件描述符，使它可以被以后的 `open`、`pipe` 或 `dup` 系统调 用所重用(见下文)。新分配的文件描述符总是当前进程中最小的未使用描述符。

文件描述符和 `fork` 相互作用，使 I/O 重定向易于实现。`fork` 将父进程的文件描述符表 和它的内存一起复制，这样子进程开始时打开的文件和父进程完全一样。系统调用 `exec` 替 换调用进程的内存，但会保留文件描述符表。这种行为允许 shell 通过 `fork` 实现 I/O 重定向， 在子进程中重新打开所选的文件描述符，然后调用 `exec` 运行新程序。下面是 shell 运行 `cat < input.txt` 命令的简化版代码。

```c
char *argv[2];

argv[0] = "cat";
argv[1] = 0;

if (fork() == 0)
{
  close(0);
  open("input.txt", O_RDONLY);
  exec("cat", argv);
}
```

在子进程关闭文件描述符 0 后，`open` 保证对新打开的 input.txt 使用该文件描述符 0。 因为此时 0 将是最小的可用文件描述符。然后 `cat` 执行时，文件描述符 0(标准输入)引用 input.txt。这不会改变父进程的文件描述符，它只会修改子进程的描述符。

xv6 shell 中的 I/O 重定向代码正是以这种方式工作的(`user/sh.c:82`)。回想一下 shell 的 代码，shell 已经 `fork` 子 shell，`runcmd` 将调用 `exec` 来加载新的程序。

#### `open`

`open` 的第二个参数由一组用位表示的标志组成，用来控制 `open` 的工作。可能的值在 文件控制(fcntl)头(kernel/fcntl.h:1-5)中定义。`O_RDONLY`, `O_WRONLY`, `O_RDWR`, `O_CREATE`, 和 `O_TRUNC`, 它们指定 `open` 打开文件时的功能，读，写，读和写，如果文件不存在创建 文件，将文件截断为零。

现在应该清楚为什么 `fork` 和 `exec` 是分开调用的:在这两个调用之间，shell 有机会重定 向子进程的 I/O，而不干扰父进程的 I/O 设置。我们可以假设一个由 `fork` 和 `exec` 组成的系 统调用 `forkexec`，但是用这种调用来做 I/O 重定向似乎很笨拙。shell 在调用 `forkexec` 之前 修改自己的 I/O 设置(然后取消这些修改)，或者 `forkexec` 可以将 I/O 重定向的指令作为参 数，或者(最糟糕的方案)每个程序(比如 cat)都需要自己做 I/O 重定向。

虽然 `fork` 复制了文件描述符表，但每个底层文件的偏移量都是父子共享的。想一想下 面的代码。

```c
if (fork() == 0)
{
  write(1, "hello", 6);
  exit(0);
} else {
  wait(0);
  write(1, "world\n", 6);
}
```

在这个片段的最后，文件描述符 1 所引用的文件将包含数据 hello world。父文件中的 `write`(由于有了 `wait`，只有在子文件完成后才会运行)会从子文件的 `write` 结束的地方开 始。这种行为有助于从 shell 命令的序列中产生有序的输出，比如`(echo hello; echo world) >output.txt`。

#### `dup`

`dup` 系统调用复制一个现有的文件描述符，返回一个新的描述符，它指向同一个底层 I/O 对象。两个文件描述符共享一个偏移量，就像被 `fork` 复制的文件描述符一样。这是将 hello world 写进文件的另一种方法。

```c
	fd = dup(1);
	write(1, "hello ", 6); 
	write(fd, "world\n", 6);
```

如果两个文件描述符是通过一系列的 `fork` 和 `dup` 调用从同一个原始文件描述符衍生出 来的，那么这两个文件描述符共享一个偏移量。否则，文件描述符不共享偏移量，即使它们 是由同一个文件的打开调用产生的。`dup` 允许 shell 实现这样的命令: `ls existing-file non-existing-file > tmp1 2>&1`。`2>&1` 表示 2 是 1 的复制品(`dup(1)`)，即重定向错误信息到 标准输出，已存在文件的名称和不存在文件的错误信息都会显示在文件 tmp1 中。xv6 shell 不支持错误文件描述符的 I/O 重定向，但现在你知道如何实现它了。

文件描述符是一个强大的抽象，因为它们隐藏了它们连接的细节:一个向文件描述符 1 写入的进程可能是在向一个文件、控制台等设备或向一个管道写入。

### 1.3 Pipes

管道是一个小的内核缓冲区，作为一对文件描述符暴露给进程，一个用于读，一个用于 写。将数据写入管道的一端就可以从管道的另一端读取数据。管道为进程提供了一种通信方 式。

下面的示例代码运行程序 `wc`，标准输入连接到管道的读取端。

```c
int p[2];
char *argv[2];

argv[0] = "wc";
argv[1] = 0;

pipe(p); 
if(fork() == 0) {
	close(0);		// 释放文件描述符0
	dup(p[0]);	// 复制一个 p[0](管道读端)，此时文件描述符 0 (标准输入) 也引用管道读端，故改变了标准输入。
	close(p[0]);
	close(p[1]);
	exec("/bin/wc", argv);	// // wc 从标准输入读取数据，并写入到参数中的每一个文件
} else {
	close(p[0]);
	write(p[1], "hello world\n", 12);
	close(p[1]);
}
```

程序调用 `pipe`，创建一个新的管道，并将读写文件描述符记录在数组 `p` 中，经过 `fork` 后，父进程和子进程的文件描述符都指向管道。子进程调用 `close` 和 `dup` 使文件描述符 0 引 用管道的读端，并关闭 p 中的文件描述符，并调用 `exec` 运行 `wc`。当 `wc` 从其标准输入端读 取时，它将从管道中读取。父进程关闭管道的读端，向管道写入，然后关闭写端。

如果没有数据可用，管道上的 `read` 会等待数据被写入，或者等待所有指向写端的文件 描述符被关闭;在后一种情况下，读将返回 0，就像数据文件的结束一样。事实上，如果没 有数据写入，读会无限阻塞，直到新数据不可能到达为止(写端被关闭)，这也是子进程在执行上面的 `wc` 之前关闭管道的写端很重要的一个原因:如果 wc 的一个文件描述符仍然引 用了管道的写端，那么 `wc` 将永远看不到文件的关闭(被自己阻塞)。

xv6 的 shell 实现了管道，如 `grep fork sh.c | wc -l`，shell 的实现类似于上面的代码 (`user/sh.c`:100)。执行 shell 的子进程创建一个管道来连接管道的左端和右端(去看源码，不看难懂)。然后，它在管道左端(写入端)调用 `fork` 和 `runcmd`，在右端(读取端)调用 `fork` 和 `runcmd`，并等待两者的完成

> 读取端会因为管道无数据且输入端未关闭而阻塞，即只能等待左边的命令执行完才能执行右边的命令， 写入端需要将自己的输出写入到管道，或者关闭管道，右边的命令读取管道并将其作为自己的输入(可以没有参数)，

管道的右端(读取端)可以是一个命令，也可以是包 含管道的多个命令(例如，a | b | c)，它又会分叉为两个新的子进程(一个是 b，一个是 c)。 因此，shell 可以创建一棵进程树。这棵树的叶子是命令，内部(非叶子)节点是等待左右子 进程完成的进程。

原则上，我们可以让内部节点(非叶节点)运行管道的左端，但这样的实现会更加复杂。 考虑只做以下修改:修改 sh.c，使其不为 runcmd(p->left) fork 进程，直接递归运行 `runcmd(p->left)`。像这样，`echo hi | wc` 不会产生输出，因为当 `echo hi` 在 `runcmd` 中退出 时，内部进程会退出，而不会调用 `fork` 来运行管道的右端。这种不正确的行为可以通过不 在 runcmd 中为内部进程调用 exit 来修正，但是这种修正会使代码变得复杂:`runcmd` 需要 知道该进程是否是内部进程(非叶节点)。当不为 `runcmd(p->right) fork` 进程时，也会出 现复杂的情况。像这样的修改，`sleep 10 | echo hi` 就会立即打印出 `hi`，而不是 10 秒后，因 为 `echo` 会立即运行并退出，而不是等待 `sleep` 结束。由于 `sh.c` 的目标是尽可能的简单，所 以它并没有试图避免创建内部进程。

管道似乎没有比临时文件拥有更多的功能:

```sh
echo hello world | wc
```

could be implemented without pipes as

```sh
echo hello world >/tmp/xyz; wc </tmp/xyz
```

在这种情况下，管道比临时文件至少有四个优势。

- 首先，管道会自动清理自己;如果是文件重定向，shell 在完成后必须小心翼翼地删除 `/tmp/xyz`。
- 第二，管道可以传递任意长的数据流，而文件重定向则需要磁盘上有足够的空闲空间来存储所有数据。
- 第三，管道可以分阶段的并行执行，而文件方式则需要在第二个程序开始之前完成第一个程序。
- 第四，如果你要实现进程间的通信，管道阻塞读写比文件的非阻塞语义更有效率。

### 1.4 File System

#### `chdir`

xv6 文件系统包含了数据文件(拥有字节数组)和目录(拥有对数据文件和其他目录的 命名引用)。可以通过 `chdir` 系统调用来改变进程的当前目录。下面两个 `open` 打开了同一个文件(假设所有涉及的目录都存在)。

```shell
chdir("/a"); 
chdir("b"); 
open("c", O_RDONLY);

open("/a/b/c", O_RDONLY);
```

前两行将进程的当前目录改为 `/a/b`; 后面两行既不引用也不改变进程的当前目录。

#### `mkdir/mknod`

有一些系统调用来可以创建新的文件和目录: `mkdir` 创建一个新的目录，用 `O_CREATE` 标志创建并打开一个新的数据文件，以及 `mknod` 创建一个新的设备文件。这个例子说明了 这两个系统调用的使用。

```c
mkdir("/dir");
fd = open("/dir/file", O_CREATE | O_WRONLY);
close(fd);

mknod("/console", 1, 1);
```

`mknod` 创建了一个引用设备的特殊文件。与设备文件相关联的是主要设备号和次要设 备号(`mknod` 的两个参数)，它们唯一地标识一个内核设备。当一个进程打开设备文件后，内 核会将系统的读写调用转移到内核设备实现上，而不是将它们传递给文件系统。

文件名称与文件是不同的;底层文件(非磁盘上的文件)被称为 inode$^3$ ，一个 inode 可以有多个名称，称为链接。每个链接由目录中的一个项组成;该项包含一个文件名和对 inode 的引用。inode 保存着一个文件的 metadata(元数据)，包括它的类型(文件或目录或设备)， 它的长度，文件内容在磁盘上的位置，以及文件的链接数量。

> inode$^3$ : inode 是 linux 和类 unix 操作系统用来储存除了文件名和实际数据的数据结构，它是用来连接实际数据 和文件名的。

#### `fstat`

`fstat` 系统调用从文件描述符引用的 inode 中检索信息。它定义在 `stat.h (kernel/stat.h)` 的 `stat` 结构中:

```c
#define T_DIR 1 // Directory 
#define T_FILE 2 // File 
#define T_DEVICE 3 // Device
struct stat {
  int dev; // File system’s disk device 
  uint ino; // Inode number
  short type; // Type of file
  short nlink; // Number of links to file 
  uint64 size; // Size of file in bytes
};
```

#### `link`

`link` 系统调用创建了一个引用了同一个 inode 的文件(文件名)。下面的片段创建了引用了同一个 inode 两个文件 a 和 b。

```c
open("a", O_CREATE | O_WRONLY);
link("a", "b");
```

读写 a 与读写 b 是一样的，每个 inode 都有一个唯一的 inode 号来标识。经过上面的代 码序列后，可以通过检查 `fstat` 的结果来确定 a 和 b 指的是同一个底层内容:两者将返回相 同的 inode 号(ino)，并且 `nlink` 计数为 2。

#### `unlink`

`unlink` 系统调用会从文件系统中删除一个文件名。只有当文件的链接数为零且没有文 件描述符引用它时，文件的 inode 和存放其内容的磁盘空间才会被释放。

```c
unlink("a");
```

 上面这行代码会删除 a，此时只有 b 会引用 inode。

```c
fd = open("/tmp/xyz", O_CREATE | O_RDWR); unlink("/tmp/xyz");
```

这段代码是创建一个临时文件的一种惯用方式，它创建了一个无名称 inode，故会在进 程关闭 `fd` 或者退出时删除文件。

Unix 提供了 shell 可调用的文件操作程序，作为用户级程序，例如 `mkdir`、`ln` 和 `rm`。这 种设计允许任何人通过添加新的用户级程序来扩展命令行接口。现在看来，这个设计似乎是 显而易见的，但在 Unix 时期设计的其他系统通常将这类命令内置到 shell 中(并将 shell 内 置到内核中)。



### 1.5 Real world

Unix 将标准文件描述符、管道和方便的 shell 语法结合起来进行操作，是编写通用可重 用程序的一大进步。这个想法引发了一种软件工具文化，这也是 Unix 强大和流行的主要原 因，而 shell 是第一种所谓的脚本语言。Unix 系统调用接口今天仍然存在于 BSD、Linux 和 Mac OS X 等系统中。

Xv6 并不符合 POSIX 标准:它缺少许多系统调用(包括基本的系统调用，如 lseek)， 而且它提供的许多系统调用与标准不同。我们对 xv6 的主要目标是简单明了，同时提供一个 简单的类似 UNIX 的系统调用接口。一些人已经添加了一些系统调用和一个简单的 C 库扩展 了 xv6，以便运行基本的 Unix 程序。然而，现代内核比 xv6 提供了更多的系统调用和更多种 类的内核服务。例如，它们支持网络、窗口系统、用户级线程、许多设备的驱动程序等等。 现代内核不断快速发展，并提供了许多超越 POSIX 的功能。

Unix 用一套文件名和文件描述符接口统一了对多种类型资源(文件、目录和设备)的访 问。这个思想可以扩展到更多种类的资源，一个很好的例子是 Plan 9[13]，它把资源就是文 件的概念应用到网络、图形等方面。然而，大多数 Unix 衍生的操作系统都没有遵循这一路线。

文件系统和文件描述符已经是强大的抽象。即便如此，操作系统接口还有其他模式。 Multics 是 Unix 的前身，它以一种使文件存储看起来像内存的方式抽象了文件存储，产生了 一种截然不同的接口。Multics 设计的复杂性直接影响了 Unix 的设计者，他们试图建立一些 更简单的东西。

Xv6 没有用户系统;用 Unix 的术语来说，所有的 xv6 进程都以 root 身份运行。

本书研究的是 xv6 如何实现其类似 Unix 的接口，但其思想和概念不仅仅适用于 Unix。 任何操作系统都必须将进程复用到底层硬件上，将进程相互隔离，并提供受控进程间通信的 机制。在学习了 xv6 之后，您应该能够研究其他更复杂的操作系统，并在这些系统中看到 xv6 的基本概念。

## 第2章 操作系统的组织形式

操作系统必须满足三个要求：多路复用、隔离、交互

> 本章概述了如何组织操作系统来实现前述3个要求。
>
> 虽然已证明有很多方式来实现这3个要求，但是本文重点关注有关整体内核的主流设计，比如许多Unix操作系统使用的就是这种设计。
>
> 本章也概述了xv6进程，其中进程是xv6系统的隔离单元。
>
> 本章也概述了当 xv6 启动时，第一个进程是如何创建的。

- 操作系统的一个关键要求是要一次支持多个活动。比如，使用系统调用fork，一个进程可以启动新进程。
- 操作系统必须在这些进程间分时共享计算机资源。比如，即使系统中的进程数比硬件CPU多，则操作系统也必须保证所有进程都有执行的机会。

- 操作系统必须安排进程之间的隔离。即， 如果一个进程里有错误，并出现故障，则不应影响不依赖该进程的那些进程。但是，彻底地隔离又太强了，因为进程间可能存在交互，比如管道。


xv6 运行在多核 RISC-V 微处理器上，许多底层功能 (例如，它的进程实现) 是 RISC- V 所特有的

> RISC-V 是一个64位的CPU，xv6 是用`LP64`C编写的，表示在 C 语言里的 long 和 pointer 是64位的，而不是32位。
>
> 有关 RISC-V 的有用的参考是《The RISC-V Reader: An Open Architecture Atlas》
>
> 在一台完整的电脑上的CPU是被支持硬件包围着的，其中的大部分都是I/O接口。
>
> 通过 `qemu`的`-machine virt`选项，可为支持硬件编写xv6。这里的支持硬件包括
>
> - RAM
> - 一个包含启动代码的ROM
> - 用户键盘/屏幕的串行连接
> - 一个存储用的磁盘

### 2.1 Abstracting physical resources

If no OS：类库 -> 实现系统调用，应用通过链接到类库的方式来使用类库。

- 每个应用甚应用至可以根据自身需要量身定制自己的类库。
- 应用能直接跟硬件资源交互，以对应用最优的方式来使用硬件资源。
- 一些嵌入式设备或者实时系统采用这种组织形式。

类库方法的缺点是：

- 如果有多个应用在运行，则这些应用必须有良好的行为，比如每个应用必须周期性地放弃CPU，以便其他应用可以运行。
- 如果所有的应用都彼此信任，且没有错误，则这种协作式分时共享策略是可行的。由于对于应用来说，更常见的是彼此不信任，或者有错误。所以我们想要的隔离度要比协作式策略更强。

换句话说，协作式策略需要的隔离是弱隔离。

- 禁止应用直接访问敏感的硬件资源，转而将资源抽象为服务，对实现强隔离是有帮助的。

  > 比如，UNIX应用只能通过文件系统的`open`、`read`、`write`、`close`等系统调用来跟存储交互，而不是直接读写磁盘。
  >
  > UNIX的文件系统为应用提供了路径名，且允许操作系统来管理磁盘。

即使不关心隔离特性，那些存在交互或者只希望彼此保持隔离的程序也可能会发现：文件系统是一个比直接使用磁盘更方便的抽象。

- 类似地，通过按需保存和恢复寄存器状态，UNIX透明地在多个进程间切换硬件CPU，使得应用自身意识不到分时共享。

- 这种透明性允许：即使有应用陷入死循环，则操作系统仍可以共享CPU。

  > 比如，UNIX进程使用`exec`来构建它的内存映像，而不是直接跟物理内存交互。这样就允许：
  >
  > - 操作系统决定进程在内存中的放置位置。
  > - 如果内存不够用的话，则操作系统甚至会将进程的数据保存在磁盘上。
  > - `exec`为用户提供了方便的文件系统来存储可执行程序映像。

UNIX进程间的许多进程的交互方式都是通过文件描述符发生的。

- 不仅抽象了许多细节(比如数据是存储在管道里还是文件里等)，

- 还是以简化交互的形式定义的。

  > 比如，如果在管道中的一个应用失败了，则内核会为管道中的下一个进程生成一个`end-of-file`的信号。

为了既为程序员提供方便，也提供强隔离，则在图1.3中的系统调用接口是经过仔细设计的。

### 2.2 User mode, supervisor mode, and system calls

强隔离：则操作系统必须安排好使得应用不能修改操作系统的数据结构和指令，不能访问其他进程的内存。

CPU为强隔离提供硬件上的支持，比如，RISC-V有3种CPU执行指令的模式

- 机器模式
  - 在机器模式下执行指令具有完整的特权。机器模式主要用于配置计算机。
  - xv6在机器模式下执行若干行指令，然后切换到超级用户模式。
- 超级用户模式
  - 在超级用户模式下，允许CPU执行特权指令，比如使中断生效和失效、读写持有页表地址的寄存器等。
- 用户模式
  - 如果处于用户模式的应用尝试去执行一个特权指令，则CPU不会执行该指令，而是切换到超级用户模式，使得超级用户代码能终止该应用，因为应用做了本不应该它做的事。

运行模式切换：

- 应用只能执行用户模式的指令(比如，将数字相加等)，称该软件在用户控件运行。
- 在超级用户模式下的软件也能执行特权指令，称该软件在内核空间运行。
  - 在内核空间中运行的软件成为内核。想调用内核功能(比如xv6中的`read`系统调用)的的应用必须要切换到内核。
- CPU提供了一个特定指令(RISC-V提供了`ecall`指令)，该指令的功能是从用户模式切换到超级用户模式的特定指令，进入内核的指定位置。
  - 一旦CPU切换到了超级用户模式，则内核就能验证该系统调用的参数，决定是否允许应用执行请求操作，拒绝执行或者执行。
  - 重要的是内核控制着切换到超级用户模式的入口点。如果应用能决定内核的进入点，则一个恶意的应用就能在一个跳过验证参数的点进入内核。

### 2.3 内核的组织结构

> 一个很关键的设计问题：操作系统的哪些部分应该以超级用户模式运行？
>

#### 思路1：宏内核monolithic kernel

整个操作系统都驻留在内核，使得所有的系统调用都是在超级用户模式下运行。在整体内核中，整个操作系统运行时都具有完整的硬件特权。

##### 优点：

这样的组织很方便——

- 操作系统的设计者不用判断操作系统的哪一部分不需要完整的特权。
- 操作系统的各个部分之间协作起来会更容易，比如操作系统可能有一个被文件系统和虚拟内存系统共用的缓冲区缓存。

##### 缺点：

- 操作系统的不同部分之间的接口通常会很复杂，从而导致操作系统的开发者很容易就犯错。
- 在整体内核中，出一个错就是致命的，因为在超级用户模式下的一个错误通常会导致内核崩溃。
- 如果内核崩溃了，则计算机将停止工作，进而所有应用都失败了。计算机必须重新启动了。

#### 思路2：微内核 microkernel

为了降低内核中出错的风险，操作系统的设计者要

- 最小化能以超级用户模式运行的操作系统代码的数量；
- 以用户模式执行操作系统剩余的大部分代码；

图2.1说明了这种微内核设计。

![f-21](f-21.png)

作为进程运行的OS服务称为服务器，文件系统作为一个用户级别的进程在运行。

在图中，文件系统作为一个用户级进程运行。作为进程运行的 OS 服务称为服务器。

为了让应用程序与文件服务器进行交互，内核提供了一种进程间通信机制，用于从一个用户模式进程向另一个进程发送消息。

> 例如，如果一个像 shell 这样的应用程序想要读写文件，它就会向文件服务器发送一个消息，并等待响应。

在微内核中，内核接口由一些低级函数组成，用于启动应用程序、发送消息、访问设备硬件等。这种组织方式使得内核相对简单，因为大部分操作系统驻留在用户级服务器中。

xv6 和大多数 Unix 操作系统一样，是以宏内核的形式实现的。

- 因此，xv6 内核接口与操作系统接口相对应，内核实现了完整的操作系统。
- 由于 xv6 不提供很多服务，所以它的内核比一些微内核要小，但从概念上讲 xv6 是宏内核。

### 2.4 Code: xv6 organization

xv6的内核源代码是在`kernel`子目录下。模块间接口被定义在`defs.h`中。

遵循粗略的模块化概念，它被分成许多文件:

![f-22](f-22.png)

### 2.5 Process overview

`xv6` 里的一个隔离单元就是一个进程。

- 进程抽象可以防止一个进程破坏或者监视另一个进程的内存、CPU、文件描述符等。
- 进程抽象还可以防止一个进程破坏内核，以便一个进程不能颠覆内核的隔离机制。

内核必须仔细地实现隔离机制，内核用来实现进程的机制包括

- 用户/超级用户模式标记
- 地址空间
- 线程的时间分片等

为了有助于加强隔离度，进程抽象为程序提供了私有机器，私有的内存系统（地址空间），私有的 CPU（用来执行指令）

xv6使用页表（通过硬件来实现）来给予每个进程自己的地址空间。RISC-V 页表将虚拟地址(RISC-V指令能操作的地址)映射到物理地址(CPU芯片发送给主内存的地址)。

![f-23](f-23.png)

xv6为每个进程维护一张单独的页表，该页表定义了进程的地址空间。如图 2.3 所示，进程的 用户空间内存的地址空间从虚拟地址 0 开始的。

- 指令存放在最前面，
- 全局变量其次
- 栈
- 堆区(用于 `malloc`)，进程可以根据需要扩展
- `trampoline`
- `trapframe`

一些因素限制了进程地址空间的最大长度：

- RISC-V 上的指针是 64 位宽；
- 硬件在页表中查找虚拟地址时只使用低的 39 位；
- xv6 只使用 39 位中的 38 位。

因此，最大的地址是 $2^{38}-1=0x3fffffffff$，即 `MAXVA` (定义可见`kernel/risv.h`)。在地址空间的顶部，xv6 保留了一页，用于 `trampoline` 和映射进程 `trapframe` 的页，以便切换到内核，我们将在第 4 章中解释。

> 这里留了两个问题：
>
> - 什么是 trampoline？
> - 什么是 trapframe？

xv6 内核为每个进程维护了许多状态，且将这些状态收集在了 `proc` 结构体中`kernel/proc.h:86`)。

- 一个进程最重要的内核状态片段就是页表、内核栈、运行状态。
- 我们用 `p->xxx` 来表示 proc 结构的元素，例如，`p->pagetable` 是指向进程页表的指针。

每个进程都有一个执行线程(简称线程)，执行进程的指令。

- 一个线程能被挂起，然后恢复。
- 为了在进程间透明地切换，内核会挂起当前运行线程，恢复另一个进程的线程。

线程的许多状态 (局部变量、函数调用返回地址) 是保存在线程的栈上的

- 每个进程有两个栈:用户栈 + 内核栈 (`p->kstack`)。
- 当进程在执行用户指令时，只有它的用户栈在使用，而它的内核栈是空的。
- 当进程进入内核时 (为了系统调用或中断)，内核代码在进程的内核栈上执行;
- 当进程在内核中时，它的用户栈仍然包含保存的数据，但不被主动使用。
- 进程的线程在用户栈和内核栈中交替执行。
- 内核栈是独立的(并且受到保护，不受用户代码的影响)，所以即使一个进程用户栈被破坏了，内核也可以执行。

一个进程通过执行 RISC-v 的`ecall`指令来进行系统调用。

- 该指令提升硬件特权等级，修改程序计数器到某个内核定义的入口点。

- 内核入口点的代码切换到一个内核栈，并执行实现系统调用的内核指令。

- 当系统调用完成时，内核通过调用`sret`指令来切换回用户栈并返回到用户空间。

  > 该指令降低硬件特权等级，恢复执行紧邻系统调用指令的那条用户指令。

进程的线程可以在内核中阻塞等待 I/O，当 I/O 完成后，再从离开的地方恢复。

- `p->kstack`：进程的内核栈。
- `p->state`：表示进程的状态，包括已分配、待运行、运行中、等待I/O、退出等。

`p->pagetable` 以 RISC-V 硬件需要的格式保存进程的页表。进程在用户空间执行时， xv6 使分页硬件使用进程的 `p->pagetable`。进程的页表也会记录分配给该进程内存的物理页地址。

### 2.6 Code: starting xv6 and the first process

为了使 xv6 更加具体，我们将概述内核如何启动和运行第一个进程。

RISC-V 计算机开机会初始化自己并运行存储在只读存储器中的 `boot loader`。`boot loader` 将 xv6 内核加载到内存中。

从 `_entry` (kernel/entry.S:6) CPU 在机器模式下开始执行 xv6。RISC-V 在**禁用分页硬件**的情况下启动：虚拟地址直接映射到物理地址。

`loader` 将 xv6 内核加载到物理地址 `0x80000000` 的内存中。

> 是因为地址范围 `0x0-0x80000000` 包含 I/O 设备。所以内核放在 `0x80000000` 而非 `0x0`

`_entry` 处的指令设置了一个栈，这样 xv6 就可以运行 C 代码。Xv6 在文件 `start.c(kernel/start.c:11)` 中声明了初始栈的空间，即 `stack0`。

在`_entry` 处的代码加载栈指针寄存器 `sp`，地址为 `stack0+4096`，也就是栈的顶部，因为 RISC-V 的栈是向下扩张的。现在内核就拥有了栈，`_entry` 调用 `start (kernel/start.c:21)`，并执行其 C 代码。

函数 `start` 执行一些只有在机器模式下才允许的配置，然后切换到监督者模式。为了进入监督者模式，RISC-V 提供了指令 `mret`。 这条指令最常用来从上一次的调用中返回，上一次调用从监督者模式到机器模式。

`start` 并 不是从这样的调用中返回，而是把事情设置得像有过这样的调用一样：它在寄存器 `mstatus` 中把上一次的特权模式设置为特权者模式，它把 `main` 的地址写入寄存器 `mepc` 中，把返回地址设置为 `main` 函数的地址，在特权者模式中把 0 写入页表寄存器 `satp` 中，禁用虚拟地址转换，并把所有中断和异常委托给特权者模式。

在进入特权者模式之前，`start` 还要执行一项任务：<u>对时钟芯片进行编程以初始化定时器中断</u>。在完成了这些基本管理后，`start` 通过调用 `mret` "返回" 到监督者模式。这将导致程序计数器变为 `main(kernel/main.c:11)` 的地址。

在 `main(kernel/main.c:11)`初始化几个设备和子系统后，它通过调用 `userinit(kernel/proc.c:212)` 来创建第一个进程。第一个进程执行一个用 RISC-V 汇编编写的小程序 `initcode.S(user/initcode.S:1)`，它通过调用 `exec` 系统调用重新进入内核。正如我们在第一章中所看到的，`exec` 用一个新的程序(本例中是 `/init`) 替换当前进程的内存和寄存器。 一旦内核完成 `exec`，它就会在 `/init` 进程中返回到用户空间。`init(user/init.c:15)` 在需要时会创建一个新的控制台设备文件，然后以文件描述符 0、1 和 2 的形式打开它。然后它在控制台上启动一个 shell。这样系统就启动了。

### 2.7 Real World

在现实世界中，既可以找到宏内核，也可以找到微内核。许多 Unix 内核都是宏内核。 例如，Linux 的内核，尽管有些操作系统的功能是作为用户级服务器运行的 (如 windows 系统)。L4、Minix 和 QNX 等内核是以服务器的形式组织的微内核，并在嵌入式环境中得到了广泛的部署。大多数操作系统都采用了进程概念，大多数进程都与 xv6 的相似。

然而，现代操作系统支持进程可以拥有多个线程，以允许一个进程利用多个 CPU。在一个进程中支持多个线程涉及到不少 xv6 没有的机制，包括潜在的接口变化 (如 Linux 的 `clone`， `fork` 的变种)，以控制线程共享进程的哪些方面。

## Chapter 3 Page tables

页表是操作系统为每个进程提供自己私有地址空间和内存的机制。页表决定了**内存地址**的含义，以及物理内存的哪些部分可以被访问。它们允许 xv6 隔离不同进程的地址空间，并 将它们映射到物理内存上。页表还提供了一个间接层次，允许 xv6 执行一些技巧:在几个地 址空间中映射同一内存(trampoline 页)，以及用一个未映射页来保护内核和用户的栈。本章 其余部分将解释 RISC-V 硬件提供的页表以及 xv6 如何使用它们。

### 3.1 Paging hardware

RISC-V 指令(包括用户和内核)操作的是虚拟地址。机器 RAM，或者说物理内存，是用物理地址来做索引的，RISC-V 分页硬件 (一般指内存管理单元(Memory Management Unit, MMU)) 将这两种地址联系起来，通过将每个虚拟地址映射到物理地址上。

xv6 运行在 `Sv39 RISC-V` 上，这意味着只使用 64 位虚拟地址的底部 39 位，顶部 25 位未被使用。在这种 `Sv39` 配置中，一个 RISC-V 页表在逻辑上是一个 $2^{27}(134,217,728)$ 页表项 $(Page Table Entry, PTE)$ 的数组。每个 $PTE$ 包含一个 44 位的物理页号 $(Physical Page Number，PPN)$ 和一些标志位。分页硬件通过利用 39 位中的高 27 位索引到页表中找到一 个 $PTE$ 来转换一个虚拟地址，并计算出一个 56 位的物理地址，它的前 44 位来自于 $PTE$ 中的 $PPN$，而它的后 12 位则是从原来的虚拟地址复制过来的。图 3.1 显示了这个过程，在逻辑上可以把页表看成是一个简单的 $PTE$ 数组(更完整的描述见图 3.2)。页表让操作系统控 制虚拟地址到物理地址的转换，其粒度为 $4096(2^{12})$ 字节的对齐块。这样的分块称为页。

在 Sv39 RISC-V 中，虚拟地址的前 25 位不用于转换地址;将来，RISC-V 可能会使用这些位来定义更多的转换层。物理地址也有增长的空间：在 $PTE$ 格式中，物理页号还有 10 位 的增长空间。

![f-31](f-31.png)



## 第4章 陷阱和系统调用

有3类事件可导致CPU把普通的指令执行搁置在一边，强制把控制权转移到能处理事件的特定代码处。

- 系统调用
  用户程序执行`ecall`指令来请求内核为它做一些事；
- 异常
  一条指令(用户或者内核)做了非法的事，比如除以0、使用了一个非法的虚拟地址等；
- 设备中断
  设备发出了需要关注的信号，比如磁盘完成了读或者写操作等

本书中使用陷阱trap作为这3种情形的泛称。

当陷阱出现时，无论正在执行什么代码都需要恢复，不应该感知到发生了任何特殊的事件。

即，我们通常希望陷阱是透明的，这对于中断来说极其重要，因为被中断的代码不期望感知到有特殊事件发生了。

通常的步骤是：

- 陷阱强制将控制权转交给内核；
- 内核保存寄存器及其他状态，使得执行能被恢复；
- 内核执行合适的处理代码(比如，系统调用的实现或者设备驱动)；
- 内核恢复被保存的状态，从陷阱中返回；
- 从被打断处恢复原始代码的执行；

xv6内核处理所有类型的陷阱。

- 对系统调用来说，这是很自然的事。
- 对中断来说，也是很有意义的，因为隔离性要求：用户进程不能直接访问设备，只有内核有处理设备所需的状态。
- 对异常来说，也很有意义，因为xv6对来自用户空间的所有异常的作出的响应是杀掉相应的进程。

xv6的陷阱处理分为4个阶段：

- RISC-V的CPU采取的硬件操作；
- 1个为内核C代码准备好路径的汇编向量；
- 1个决定如何处理陷阱的C陷阱处理程序；
- 系统调用或者设备驱动服务例程；

虽然这3类陷阱之间的共性建议：内核可使用一条代码路径来处理所有类型的陷阱，但是事实证明，针对用户空间陷阱、内核空间陷阱、计时器中断等3种不同的情形，有单独的汇编向量及C陷阱处理程序是很方便的。



### 4.1 RISV的陷阱机制

每个RISC-V的CPU都有一套控制寄存器，内核可向其中写入信息来告知CPU如何处理陷阱，内核可从中读数据来查找有关已发生的陷阱信息。

在`riscv.h`中包含了xv6使用的定义。

| Register       | Function                                                     |
| -------------- | ------------------------------------------------------------ |
| stvec寄存器    | 内核向其中写入中断处理程序的地址；<br/>RISC-V将跳转到这里记录的地址处理陷阱； |
| sepc寄存器     | 当陷阱发生时，RISC-V将程序计数器的值保存在这里，因为随后pc的值将被stvec的值覆盖掉；<br/>sret指令拷贝sepc的值到pc中；<br/>内核可向spec中写入值来控制sret返回到哪里； |
| scause寄存器   | RISC-V在这里放入一个数，描述的是陷阱发生的原因；             |
| sscratch寄存器 | 内核在这里放置一个值，这个值会在处理程序开始时很有用；       |
| sstatus寄存器  | 在sstatus中的SIE位控制的是设备中断是否生效；<br/>如果内核清除了SIE，则RISC-V将延迟设备中断直到内核设置了SIE。<br/>在sstatus中的SPP位记录的是陷阱来自用户模式还是超级用户模式，及控制sret返回到哪种模式。 |

> 以上5个跟陷阱相关的寄存器都是在超级用户模式下处理的，在用户模式下不能读写这5个寄存器的值。

在机器模式下，有等价的一套控制寄存器来用于陷阱处理。

xv6仅在计时器中断的特殊情况下使用这些寄存器。

在多核处理器的每个CPU都有自己的一套类似这样的寄存器；在任意给定时刻，可能不止有一个CPU在处理陷阱。

当需要强制处理一个陷阱时，RISV 硬件对除了计时器中断外的所有陷阱类型做下面几件事：

1. 如果陷阱是一个设备中断，且sstatus中的SIE标记位被清除了，则什么都不做；
2. 清除sstatus中的SIE标记，使中断失效；
3. 拷贝pc到spec；
4. 保存当前模式到sstatus的SPP标记位；
5. 设置scause寄存器来反映陷阱的起因；
6. 设置模式为超级用户模式；
7. 拷贝stvec到pc
8. 跳转到新的pc处开始执行

注意：CPU没有切换到内核的页表，没有切换到内核栈中，没有保存除了pc之外的任何寄存器。这些是内核软件必须要做的任务。

理由：CPU在处理陷阱的过程中做少量的工作是为了给软件提供更大的灵活性。比如，一些操作系统在某些情况下不需要页表切换的，这可以提升性能。

能不能对CPU的陷阱处理步骤进行进一步的简化？

- 假设CPU不切换程序寄存器pc。则还在运行用户指令，陷阱就切换到超级用户模式了。这样，那些用户指令就能破坏用户/内核隔离机制了，比如通过修改satp寄存器来指向允许访问整个物理内存的页表了。
- 因此，CPU切换到由stvec寄存器指定的内核指令地址是非常重要的。



### 4.2 来自用户空间的陷阱

- 问题：一次完整的来自用户空间的陷阱处理流程是怎样的？
- 问题：`uservec`做了哪些事？
- 问题：`usertrap`做了哪些事？
- 问题：`usertrapret`做了哪些事？
- 问题：`userret`做了哪些事？

当CPU在用户空间执行时，如果用户程序做了一个系统调用，或者做了非法的事，或者某个设备中断了，则就可能会发生一个陷阱。

处理来自用户空间的陷阱的代码路径是先`uservec`，后`usertrap`。
返回时是先`usertrapret`，后`userret`。

来自用户空间的陷阱处理代码要比来自内核的更具有挑战性：因为`satp`指向的是一个没有映射到内核的用户页表，栈指针可能包含一个无效甚至是恶意的值。

因为RISC-V硬件在陷阱期间不切换页表，则用户页表必须包含`uservec`的映射，即`stvec`指向的陷阱向量指令。

`uservec`必须切换`satp`以指向内核页表；为了在切换后继续执行指令，必须将`uservec`映射到内核页表中跟用户页表中相同的地址。

xv6使用包含`uservec`的`trampoline页`来满足这些约束。xv6将`trampoline页`映射到内核页表和每个用户页表中的虚拟地址是相同的。这个虚拟地址就是`TRAMPOLINE`。

在`trampoline.S`中设置了`trampoline`的内容。

当执行用户代码时，设置`stevec`为`uservec`。

当uservec开始执行时，所有32个寄存器包含的都是被打断代码的值。
但是，为了设置satp及生成保存寄存器值的地址，uservec需要能修改一些寄存器。

RISC-V以sscratch寄存器的形式提供了一个帮手。
在uservec开头的csrrw指令交换了a0寄存器和sscratch寄存器的值。

现在用户代码的a0寄存器的值被保存了；
uservec有一个寄存器a0可以使用了；
ao包含了内核先前放在sscratch里的值。

uservec的下一个任务是保存用户寄存器的值。
在进入用户空间前，内核之前设置sscratch指向每个进程的trapframe，该trapframe有空间来保存所有的寄存器。
由于satp仍指向用户页表，则uservec需要将trapframe映射到用户地址空间。

当创建进程时，xv6会分配一个页给该进程的trapframe，将该页映射到用户虚拟地址TRAPFRAME。进程的p->trapframe指向的就是陷阱栈，不过是它的物理地址，以便内核能通过内核页表来使用它。

因此，在交换了a0和sscratch后，a0持有了一个指向当前进程陷阱栈的指针。现在，uservec可以将所有的用户寄存器保存到陷阱栈中，包括用户的a0。

陷阱栈包含了指向当前进程内核栈的指针、当前CPU的hartid、usertrap的地址、内核页表的地址。

uservec检索这些值，切换satp指向内核页表，调用usertrap。

usertrap的工作是判断陷阱的起因，处理陷阱，并返回。
首先，修改stvec，使得陷阱在内核中将被kernelvec处理。
然后，保存sepc的值，因为在usertrap中的一个进程切换可能会导致sepc的值被覆盖。
接着，如果一个陷阱是系统调用，则syscall会处理陷阱；
如果陷阱是一个设备中断，则devintr会处理陷阱；
如果陷阱是一个异常，则内核会杀掉出错的进程；

系统调用路径会将保存的用户pc加4，因为在系统调用情形下，RISC-V会让程序指针指向ecall指令。

退出过程中，usertrap会检查进程是否被杀死，或者应该让出CPU(如果这是一个计时器中断)。

如何返回到用户空间？

第一步：调用usertrapret。
该函数先设置RISC-V的控制寄存器为将来的来自用户空间的陷阱做好准备。包括：设置stvec指向uservec，准备好uservec依赖的trapframe字段，设置sepc为先前保存的用户pc。
然后，调用在trampoline页上的userret，该trampiline页在用户页表和内核页表中都有映射，理由是在userret中的汇编码将切换页表。

usertrapret对userret的调用传递了一个指向进程用户页表(在a0中)和TRAPFRAME(在a1中)的指针。

userret切换satp指向进程的用户页表。
回想一下，用户页表既映射了trampoline页，也映射了TRPFRAME，但没有映射来自内核的其他内容。
在用户页表和内核页表中，trampoline页被映射到相同的虚拟地址，这就允许：在修改satp之后，uservec继续执行。

userret拷贝trapframe上保存的用户a0到sscratch中，为以后的TRAPFRAME交换做好准备。

从现在起，userret能使用的数据只有寄存器的内容和trapframe的内容。
接下来，userret从trapframe中恢复被保存的寄存器，做最后一次a0和sscratch的交换来恢复a0，为接下来的陷阱而保存TRAPFRAME，使用sret返回到用户空间。



### 4.3 代码：系统调用

第2章以initcode.S结束，在initcode.S中触发了exec系统调用。让我们看看用户的调用是如何抵达内核中的exec系统调用实现的。

用户代码在寄存器a0和a1中放入了用于exec的参数，在寄存器a7中放入了系统调用编号。

系统调用编号是跟syscalls数组的条目相匹配的，其中syscalls是一个由多个函数指针组成的表。

ecall 指令进入到内核，执行 uservec、usertrap，然后是syscall。

syscall从在trapframe上被保存的寄存器a7的值中检索出系统调用号，使用它作为syscalls的索引。寄存器a7包含的值为SYS_exec，导致调用系统调用实现sys_exec。

当从系统调用实现函数中返回时，syscall在p->trapframe->a0中记录返回值。由于在RISC-V上的C调用约定在寄存器a0中放入返回值，则前述操作会导致初始用户空间对exec()调用返回syscall在trapframe->a0中放入的值。

系统调用约定返回负数表示错误，0或者整数表示成功。

如果系统调用号非法，则syscall会输出错误，并返回-1。



### 4.4 代码：系统调用参数

寄存器->陷阱帧trapframe

内核中的系统调用实现需要找到用户代码传递的参数。

因为用户代码调用的是经过包装的系统调用函数，所以参数最开始是按照RISC-V的C调用约定，保存在寄存器中的。

内核的陷阱trap代码将寄存器的值保存到当前进程的陷阱帧trap frame中，内核代码是从当前进程的trapframe上找到系统调用参数的。

函数argint、argaddr、argfd分别从陷阱帧上检索第n个参数作为整数、指针、或者文件描述符。这3个函数都是调用argraw来检索到合适的被保存的用户寄存器。

有些系统调用传递指针作为参数，内核必须使用这些指针来读写用户内存。比如，系统调用exec传递给内核一个指针数组，引用的是在用户空间的字符串参数。

这些指针带来两个挑战：

1. 用户程序可能会出错或者有恶意，可能会传递给内核一个无效的指针、或者旨在骗过内核来访问内核的内存代替访问用户内存。
2. xv6的内核页表映射跟用户页表映射不一样，所以内核不能使用普通的指令来加载或者保存来自用户提供的地址。

内核实现了向用户提供的地址以及从用户提供的地址安全转移数据的功能，比如`fetchstr`函数。

诸如`exec`等文件系统调用使用fetchstr函数来从用户空间检索字符串式的文件名参数。

fetchstr函数调用copyinstr来做实际的工作。

copyinstr从用户页表pagetale中的虚拟地址srcva处最多拷贝max个字节。它使用walkaddr来遍历软件形式的页表来确定srcva对应的物理地址pa0。因为内核映射所有的RAM地址到相同的内核虚拟地址，所以copyinstr可以直接从pa0拷贝字符串字节到dst。

walkaddr会检查用户提供的虚拟地址是否属于用户地址空间，所以程序不能骗过内核去读其他内存。

类似的函数还有copyout：将数据从内核拷贝到用户提供的地址。

### 4.5 内核空间中的陷阱

来自内核空间的陷阱处理步骤

- 保存寄存器
- 处理陷阱
- 从陷阱中返回

根据是在用户空间执行代码还是在内核空间执行代码，xv6配置CPU陷阱寄存器的方式是不一样的。

当内核在CPU上执行时，内核将stvec指向在kernelvec处的汇编代码。

由于xv6已经在内核里了，kernelvec能依赖stap来设置内核页表和栈指针来引用有效的内核栈。

kernelvec保存所有的寄存器，以便被打断的代码最终能无扰动地恢复执行。

kernelvec将寄存器保存在被打断的内核线程的栈上，这是有意义的，因为此时这些寄存器的值是属于该内核线程的。如果陷阱导致切换到一个不同的线程，这一点非常重要，陷阱将实际返回到新线程的栈上，同时安全地把被打断线程的寄存器保存在自己的栈上。

在保存完寄存器后，kernelvec就跳转到kerneltrap。

kerneltrap为两类陷阱做好准备：设备中断和异常。
它调用devintr来检查和处理设备中断。如果陷阱不是设备中断，则一定是异常；如果在xv6内核中发生了异常，则通常是一个致命错误；内核调用panic并停止执行。

如果由于计时器中断调用了kerneltrap，且一个进程的内核线程正在运行，则kerneltrap调用yield来给其他进程一个运行的机会。在将来的某个时间点，总有某个线程会yied，让我们的线程及它的kerneltrap恢复执行。

当kerneltrap执行完后，需要返回到被陷阱打断的代码处。kerneltrap检索那些控制寄存器的值，返回给kernelvec。

kernelvec从栈上弹出保存的寄存器值，并执行sret；sret拷贝sepc到pc，恢复执行被打断代码的值。

由于一个yield会干扰spec和sstatus，所以kernel在一开始就先保存spec和sstatus的值。

非常值得思考的一个问题是：如果kerneltrap由于计时器中断调用了yield，则陷阱返回是如何发生的？

当CPU从用户空间进入内核，xv6设置该CPU的stvec指向kernelvec。
当内核正在执行，但stvec指向uservec时，存在一个时间窗口。
在这个时间窗口内，使设备中断失效时非常关键的。

幸运的是，RISC-V在取一个陷阱的开始就让中断失效，直到xv6设置了stvec后，才让中断生效。